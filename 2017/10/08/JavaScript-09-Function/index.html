<!DOCTYPE html><html lang="ko"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript 09. 함수 (Function) · 기린개발의 일지</title><meta name="description" content="JavaScript 09. 함수 (Function) - Girin-dev"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://girin-dev.github.io/atom.xml" title="기린개발의 일지"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/categories/" target="_self" class="nav-list-link">CATEGORY</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/girin-dev" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript 09. 함수 (Function)</h1><div class="post-info">2017년 10월 8일</div><div class="post-content"><h1 id="JavaScript-09-함수-Function"><a href="#JavaScript-09-함수-Function" class="headerlink" title="JavaScript 09. 함수 (Function)"></a>JavaScript 09. 함수 (Function)</h1><ul>
<li>특정 작업 수행을 위해 구문들을 그룹화해 놓은 개념.</li>
<li>코드의 재사용</li>
<li>객체 생성, 객체의 행위 지정(메소드), 정보의 구성/은닉, 클로저, 모듈화 등 여러 기능 수행</li>
<li>함수도 객체의 일부이며 변수나 객체, 배열 등에 저장할 수 있고, 인수 및 반환값으로도 기능할 수 있다.(일급객체의 특징)</li>
</ul>
<h2 id="함수-정의-방법-3가지-암기"><a href="#함수-정의-방법-3가지-암기" class="headerlink" title="함수 정의 방법 3가지(암기)"></a>함수 정의 방법 3가지(암기)</h2><ul>
<li><p>함수를 정의하는 방식</p>
<ol>
<li>함수선언식 (Function declaration)</li>
<li>함수표현식 (Function expression)hd</li>
<li>Function() 생성자 함수</li>
</ol>
<p><strong>함수선언식 (Function declaration)</strong></p>
</li>
<li>내부적으로 변수명과 함수명을 똑같이 만든 함수표현식으로 인식한다.</li>
<li>호이스팅에서 함수표현식과 차이가 나는데, 정의되는 위치와 무관하게 어디서든 호출할 수 있다. 반면 함수표현식은 변수 호이스팅 발생.</li>
<li><p>함수명을 생략할 수 없고 0개 이상의 매개변수(자료형 미정으로 함수 몸체에서 자료형 체크 필요) 실행 구문을 갖는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> num + num;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>함수표현식 (Function expression)</strong></p>
</li>
<li>함수는 일급객체로서의 특징을 갖는다</li>
<li>함수를 정의하고 변수에 할당하는 방식</li>
<li><p>아래 식에서 함수명 plus는 함수 안에서면 유요한 이름.(재귀적이거나 디버깅에만 쓰임)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 기명 함수표현식(이름붙은 함수 표현식)</span></div><div class="line"><span class="comment">// 호출시 함수명이 아니라 변수명으로 해야한다.</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 익명 함수표현식(이름없는 함수 포현식)</span></div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(bar(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(plus(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// Uncaught ReferenceError: plus is not defined</span></div></pre></td></tr></table></figure>
</li>
<li><p>함수표현식을 다른 변수로 새로 할당하면 객체인 함수의 특성상 동일한 참조값을 갖는다.</p>
</li>
<li><p>일반 객체와 달리 다른 변수를 재할당하면 다른 값을 갖도록 할당된다(?) 재공부 필요.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a * b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = foo;</div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">2</span>, <span class="number">5</span>), bar(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 10 10</span></div><div class="line"><span class="built_in">console</span>.log(foo === bar); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">2</span>, <span class="number">5</span>), bar(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7 10</span></div><div class="line"><span class="built_in">console</span>.log(foo === bar); <span class="comment">// false</span></div><div class="line"><span class="comment">// 이것은 변수 foo가 변경된 것이 아니라 재할당 된 것이기 때문에 값이 다르게 나온 것.</span></div></pre></td></tr></table></figure>
<p><strong>Function() 생성자 함수</strong></p>
</li>
<li>내부적으로 함수선언식은 함수표현식으로 처리되고, 함수표현식은 Function() 생성자 함수로 처리된다. 결국 앞의 두 방법은 3번의 방법을 쓰기 편하게 만들어 놓은 것.</li>
<li>성능 이슈와 함수의 호이스팅을 고려했을때 함수 표현식을 쓰는게 좋다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Function</span>([매개변수<span class="number">1</span>], [매개변수<span class="number">2</span>], ... [매개변수N], [함수 몸체] )</div><div class="line"><span class="keyword">var</span> cup = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'number'</span>, <span class="string">'return number + number'</span>);</div><div class="line"><span class="built_in">console</span>.log(cup(<span class="number">10</span>)); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="함수-호이스팅-Function-Hoisting"><a href="#함수-호이스팅-Function-Hoisting" class="headerlink" title="함수 호이스팅 (Function Hoisting)"></a>함수 호이스팅 (Function Hoisting)</h2><ul>
<li>호이스팅이란 var나 function 등의 선언문을 해당 Scope의 맨 위로 옮기는 것.</li>
<li>자바스크립트 엔진이 스크립트 로딩되는 그 시점에 바로 함수선언식으로 정의된 함수를 한번에 선언, 초기화, 할당해버린다. (VO, variable object에 저장)</li>
<li><p>이 때문에 <strong>함수선언식의 경우 어디에서 선언하든 호출이 가능하다.</strong> 그러나 이런 식의 코드는 비추.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 함수선언식</span></div><div class="line"><span class="keyword">var</span> foo = plus(<span class="number">5</span>,<span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">apple</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line"> <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ES6는 <code>let</code>, <code>const</code>를 포함한 모든 선언(var, let, const, function, class)를 호이스팅</p>
</li>
<li><strong>함수표현식</strong> 은 변수 호이스팅이 발생하기 때문에 변수 생성, undefined으로 초기화만 진행되고, 선언할 때 할당된다. 스크립트 로딩 시점에 VO에 함수를 할당하는 함수선언식과 구분.</li>
<li>우리의 논리적 직관에 맞지 않고 VO에 부담을 주는 함수선언식보다 함수표현식을 쓸 것을 추천(Douglas Crockford)</li>
</ul>
<h2 id="First-class-object-일급객체"><a href="#First-class-object-일급객체" class="headerlink" title="First-class object (일급객체)"></a>First-class object (일급객체)</h2><ul>
<li>일급객체의 조건<blockquote>
<ol>
<li>무명의 리터럴로 표현 가능</li>
<li>변수나 자료구조(객체, 배열..)에 저장 가능</li>
<li>함수의 파라미터로 전달 가능<br>(함수의 인자로 다른 함수를 넣을 수 있다. -콜백함수)</li>
<li>반환값(return value)으로 사용 가능<br>(이렇게 짜여진 남의 코드를 독해할 줄 알아야 한다.)</li>
</ol>
</blockquote>
</li>
<li>javascript 함수는 일급객체</li>
<li>다른 객체와 구별되는 특징: 호출 가능</li>
</ul>
<h2 id="매개변수-Parameter-인자"><a href="#매개변수-Parameter-인자" class="headerlink" title="매개변수 (Parameter, 인자)"></a>매개변수 (Parameter, 인자)</h2><p>  함수내 변수와 동일하게 작동</p>
<ul>
<li><p>매개변수 (Parameter, 인자)와 인수(argument)</p>
<ul>
<li>매개변수는 인수가 할당된 파라미터에 할당된 것.</li>
<li>인수를 전달받지 못한 매개변수는 undefined로 초기화된다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">p1, p2</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(p1, p2);</div><div class="line">&#125;</div><div class="line">foo(<span class="number">1</span>); <span class="comment">// 1 undefined</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Call-by-value</p>
<ul>
<li>기본자료형의 동작방식</li>
<li>함수 호출시 기본자료형 인수를 매개변수로 전달할 때, 매개변수에 값을 복사하여 함수로 전달하는 방식</li>
<li>따라서 함수 내에서 전달된 인수의 값이 변경되었다고 해도 전달이 완료된 기본자료형 값은 변경되지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">primitive</span>)</span>&#123;</div><div class="line">  primitive += <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> primitive;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo(x)); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 0</span></div><div class="line"><span class="comment">// 함수 foo를 통해 함수 내 인수(x)의 값이 변경되었으나 기존의 기본자료형 전역변수인 x는 그대로 0이다.</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Call-by-reference</p>
<ul>
<li>함수의 인자(매개변수)에 외부의 객체를 전달했을때, 해당 함수에서 객체의 값이 변경되면, 외부의 원래 객체의 값도 같이 변경된다. (객체는 변경가능하니까)</li>
<li><p>Pass-by 와 동일한 작동. pass와 call는 용어가 다르지만 사용처의 차이일 뿐.(pass는 변수, call은 함수)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeVal</span>(<span class="params">primitive, obj</span>)</span>&#123;</div><div class="line">  primitive += <span class="number">10</span>;</div><div class="line">  obj.name = <span class="string">'Yi'</span>;</div><div class="line">  obj.gender = <span class="string">'male'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> num = <span class="number">100</span>;</div><div class="line"><span class="keyword">var</span> objt = &#123;</div><div class="line">  name: <span class="string">'Park'</span>,</div><div class="line">  gender: <span class="string">'female'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 100;</span></div><div class="line"><span class="built_in">console</span>.log(objt); <span class="comment">// Object &#123;name: 'Park', gender: 'female'&#125;</span></div><div class="line"></div><div class="line">changeVal(num, objt);</div><div class="line"></div><div class="line"><span class="comment">// 함수를 통해 매개변수로 받은 인수를 변경하면</span></div><div class="line"><span class="comment">// num은 기본자료형으로 그 값이 변하지 않지만</span></div><div class="line"><span class="comment">// objt는 객체로 그 값이 변한다.</span></div><div class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 100;</span></div><div class="line"><span class="built_in">console</span>.log(objt); <span class="comment">// Object &#123;name: 'Yi', gender: 'male'&#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p>순수함수와 비순수함수</p>
<ul>
<li>순수함수<br>외부에 영향을 주지 않는 함수</li>
<li>비순수 함수<br>위 <code>changeVal</code>과 같이 외부에 영향을 주는 함수<br>외부 객체를 인자로 갖고 있는 함수일 확률이 높고 의도치 않은 값의 변경이 나타날 수 있음.<br>즉, 코드의 예측성을 떨어뜨림.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="반환값-return-value"><a href="#반환값-return-value" class="headerlink" title="반환값 (return value)"></a>반환값 (return value)</h2><ul>
<li><code>return</code>을 만나면 함수 진행을 중단하고 함수를 호출한 코드로 되돌아간다.</li>
<li><code>return</code>이 없으면 <code>undefined</code>을 반환.</li>
<li>비순수함수의 경우 의도적으로 return을 생략하기도 한다. (외부 값 변경을 막기 위해서)</li>
</ul>
<h2 id="함수의-객체-프로퍼티"><a href="#함수의-객체-프로퍼티" class="headerlink" title="함수의 객체 프로퍼티"></a>함수의 객체 프로퍼티</h2><ul>
<li>함수도 객체이기 때문에 프로퍼티를 갖는다.</li>
<li>일반 객체와 달리 함수만의 표준 프로퍼티를 갖는다.</li>
<li>arguments, caller, length, name, prototype, __proto__</li>
</ul>
<ol>
<li>arguments</li>
</ol>
<ul>
<li><p>유사 배열 객체(순회가능)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">return</span> x * y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(multiply());     <span class="comment">// &#123;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(multiply(<span class="number">1</span>));    <span class="comment">// &#123; '0': 1 &#125;</span></div><div class="line"><span class="built_in">console</span>.log(multiply(<span class="number">1</span>,<span class="number">2</span>));  <span class="comment">// &#123; '0': 1, '1': 2 &#125;</span></div><div class="line"><span class="built_in">console</span>.log(multiply(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));<span class="comment">// &#123; '0': 1, '1': 2, '2': 3 &#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p>여기서 ‘0’은 프로퍼티명, 1은 프로퍼티값. 프로퍼티명을 0,1,2,3,…. 이런 순서로 갖고 있기 때문에 배열처럼 쓰이는 객체다~라고하면서 유사배열객체라고 한다.</p>
</li>
<li><p>매개변수를 몇개 받아야 할지 판단할 수 없거나 이용자의 판단에 맡겨야 하는 상황이라면, 이때 아예 매개변수를 의도적으로 쓰지 않고 유사배열객체인 arguments를 사용한다. 이를 가변 인자 함수 구현이라고 한다.</p>
</li>
</ul>
<ol>
<li>caller</li>
</ol>
<ul>
<li>자신을 호출한 함수 의미</li>
</ul>
<ol>
<li>length</li>
</ol>
<ul>
<li>매개변수의 갯수</li>
</ul>
<ol>
<li>name</li>
</ol>
<ul>
<li>함수명</li>
<li>익명함수의 경우 빈 문자열을 값으로 가짐</li>
</ul>
<ol>
<li>__proto__</li>
</ol>
<ul>
<li>프로토타입 체인, [[Prototype]] 프로퍼티</li>
<li>자식에게 없으면 생성자함수로 가는게 아니라 부모를 찾아간다. 엄밀히 말하면 부모-자식관계가 아니라 부모 역할을 하는 프로토타입 객체를 찾는데 거기도 없으면 쭉 찾아서 Object prototype까지 가서 있으면 출력, 없으면 Reference Error 출력.</li>
</ul>
<ol>
<li>prototype</li>
</ol>
<ul>
<li>함수 객체만이 갖고 있는 프로퍼티(객체지향의 근간)</li>
<li><p>함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[객체생성자함수명].prototype.[프로퍼티명]= “[어떤값]”</div></pre></td></tr></table></figure>
</li>
<li><p>위 코드의 경우 실행결과가 [객체생성자함수명]이 만든 모든 인스턴스에 동시에 적용이 된다. 공통적인 내용을 다수의 인스턴스가 적용할 때 하나하나 일일히 인스턴스마다 추가해 주는 것은 비효율적이기 때문에 사용된다. 예를 들면 Person.prototype이라는 부모에 sayHello= “[어떤값]” 을 추가해놓으면 알아서 자동으로 모든 인스턴스가 해당 값을 갖게 된다.</p>
</li>
</ul>
<h2 id="함수의-다양한-형태"><a href="#함수의-다양한-형태" class="headerlink" title="함수의 다양한 형태"></a>함수의 다양한 형태</h2><ul>
<li><p>즉시호출함수표현식(IIFE, Immediately Invoke Function Expression)</p>
<ul>
<li>최초 한번만 호출되어 재호출 불가.</li>
<li>초기화 처리 등에 사용.</li>
<li>변수명 충돌을 방지하는 목적으로도 사용.(jQuery 등 여러 라이브러리의 변수들의 변수명 충돌 방지)</li>
<li>서버같은거 설정 바뀌면 껏다 켜야 하는데 이 경우가 설정파일을 실행 후 딱 한번만 읽게 하는 것으로 이 경우에 사용가능.</li>
<li>전역변수로 골머리를 앓는데 이때도 유용. 전역변수를 하나도 안 쓸 수 있음.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 기명 즉시실행함수(named immediately-invoked function expression)</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">namedFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">4</span>;</div><div class="line">  <span class="keyword">return</span> a * b;</div><div class="line">&#125;());</div><div class="line"></div><div class="line"><span class="comment">// 익명 즉시실행함수(immediately-invoked function expression)</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">4</span>;</div><div class="line">  <span class="keyword">return</span> a * b;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>내부함수 (Inner function)</p>
<ul>
<li>전역/지역 구분 필요</li>
<li>함수 내부에 정의된 함수</li>
<li>내부함수(자식)는 부모함수의 변수에 접근할 수 있다.</li>
<li>부모함수는 자식함수의 변수에 접근할 수 없다.</li>
<li>내부함수는 부모함수 외부에서 접근할 수 없다.</li>
</ul>
</li>
<li><p>콜백함수 (Callback function)</p>
<ul>
<li>명시적 호출이 아닌 특정 이벤트 발생시 시스템에 의해 호출되는 함수</li>
<li>이벤트 핸들러가 대표적인 예</li>
<li>비동기식 처리 모델에 사용(처리가 종료되었을때 호출될 함수(콜백함수)를 미리 매개변수에 전달해 놓았다가, 실제 처리가 종료되면 콜백함수 호출)<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"myButton"</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="comment">// 특정 이벤트(클릭)이 발생했을때 시스템에 의해 호출.</span></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>);</span></div><div class="line"><span class="javascript">    button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'button clicked!'</span>);</span></div><div class="line"><span class="undefined">    &#125;);</span></div><div class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/10/08/JavaScript-10-Prototype/" class="prev">이전글</a><a href="/2017/10/07/JavaScript-07-Object/" class="next">다음글</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'girin-dev';
var disqus_identifier = '2017/10/08/JavaScript-09-Function/';
var disqus_title = 'JavaScript 09. 함수 (Function)';
var disqus_url = 'http://girin-dev.github.io/2017/10/08/JavaScript-09-Function/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//girin-dev.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 <a href="http://girin-dev.github.io">Girin-dev</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>