<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>기린개발의 일지</title>
  
  <subtitle>Girin-dev&#39;s development Blog.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://girin-dev.github.io/"/>
  <updated>2019-01-03T04:56:30.588Z</updated>
  <id>http://girin-dev.github.io/</id>
  
  <author>
    <name>Girin-dev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ECMAScript6 함수와 추상적 사고</title>
    <link href="http://girin-dev.github.io/2019/01/03/ECMAScript6-function-abstract/"/>
    <id>http://girin-dev.github.io/2019/01/03/ECMAScript6-function-abstract/</id>
    <published>2019-01-03T04:52:36.000Z</published>
    <updated>2019-01-03T04:56:30.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="13-1-서브루틴으로서의-함수"><a href="#13-1-서브루틴으로서의-함수" class="headerlink" title="13.1 서브루틴으로서의 함수"></a>13.1 서브루틴으로서의 함수</h2><ul><li>서브루틴<ul><li>매우 단순하고 범용적인, 호출할 수 있는 한 단위</li><li>유사어 - 프로시저, 루틴, 서브프로그램, 매크로</li></ul></li><li>함수이름의 중요성<ul><li>함수명은 누가 봐도 바로 알 수 있게 명명하는 것이 좋음</li></ul></li></ul><h2 id="13-2-값을-반환하는-서브루틴으로서의-함수"><a href="#13-2-값을-반환하는-서브루틴으로서의-함수" class="headerlink" title="13.2 값을 반환하는 서브루틴으로서의 함수"></a>13.2 값을 반환하는 서브루틴으로서의 함수</h2><ul><li>한단계 더 추상화</li><li>불리언이 필요한 컨텍스트에서 쓰도록 만든 함수명엔 <code>is</code>가 맨 앞에 들어가는게 일반적이며, “현재기준”이 중요하다면 <code>current</code>가 들어감</li></ul><h2 id="13-3-함수로서의-함수"><a href="#13-3-함수로서의-함수" class="headerlink" title="13.3 함수로서의 함수"></a>13.3 함수로서의 함수</h2><ul><li>순수함수<ul><li>수학적 정의에 충실한 함수</li><li>입력이 들어가면 결과가 나오는 관계</li></ul></li><li>순수함수와 일반적함수의 차이점<ul><li><ol><li>순수함수에선 입력이 같으면 결과도 같다.(일반적 함수는 입력을 안 받기도 하고, 입력이 아닌 다른 요소에 의해 결과가 바뀌기도 함)</li></ol></li><li><ol start="2"><li>순수함수에는 부수효과가 없다.<ul><li>부수효과: 함수에 속하는 않는 변수가 바뀐다는 등 함수 이외에서 나타나는 효과</li><li>함수를 호출했다고 해서 프로그램의 상태가 바뀌어선 안 된다.</li></ul></li></ol></li></ul></li><li>일반함수를 순수함수로 바꿔보자<ul><li>외부변수를 클로저로 감싸는 것도 방법</li><li>이터레이터를 쓸 수 있음<ul><li>이터레이터는 독립적이므로 다른 프로그램에서 이터레이터를 생성해 다루더라도 다른 이터레이터를 간섭하지 않는다.</li><li><code>next</code>는 매번 다른 값을 반환할테니 문제를 뒤로 미룬 것이긴 하지만 그래도 순수함수임.</li></ul></li></ul></li></ul><h2 id="13-4-그래서-함수는-왜"><a href="#13-4-그래서-함수는-왜" class="headerlink" title="13.4 그래서 함수는 왜?"></a>13.4 그래서 함수는 왜?</h2><ul><li>함수의 3가지 측면</li></ul><ol><li>서브루틴</li><li>값을 반환하는 서브루틴</li><li>순수함수</li></ol><ul><li>함수는 왜 쓰는가?<ul><li>반복을 없애기 위해</li></ul></li><li>순수함수는 왜 쓰는가?<ul><li>순수한 함수를 쓰면 코드를 테스하기 쉽고, 이해하기 쉽고, 재사용하기도 쉽다.</li><li>컨텍스트에 좌우되는 함수(상황에 따라 다른 값 반환, 부수효과 등)는 다른 프로그램에서 사용하려 할 때 문제 발생</li><li>순수함수 권장(습관화하자)</li><li>객체지향 프로그래밍은 스코프를 밀접하게 관리하여 함수의 부수효과 제어</li></ul></li></ul><h3 id="13-4-1-함수도-객체다"><a href="#13-4-1-함수도-객체다" class="headerlink" title="13.4.1 함수도 객체다."></a>13.4.1 함수도 객체다.</h3><ul><li>자바스크립트 함수는 <code>Function</code> 객체의 인스턴스</li><li><code>typeof v</code>로 함수인지 아닌지 정확히 알 수 있다.</li><li><code>v instanceof Object</code>도 true이기 때문에 (객체가 아닌) 함수임을 알고 싶다면 <code>typeof v</code>를 쓰자</li></ul><h2 id="13-5-IIFE와-비동기적코드"><a href="#13-5-IIFE와-비동기적코드" class="headerlink" title="13.5 IIFE와 비동기적코드"></a>13.5 IIFE와 비동기적코드</h2><ul><li>IIFE(즉시 호출하는 함수표현식)으로 비동기적 코드를 처리해보자</li><li><p>‘5,4,3,2,1,go!’을 출력하는 코드를 짜보자</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">5</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i===<span class="number">0</span> ? “go!” : i);</span><br><span class="line">    &#125;, (<span class="number">5</span>-i)*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>위 코드는 5, 4, 3, 2, 1, go! 가 출력될 것 가지만 -1만 6번 출력된다. </p></li><li>원인은<ul><li>setTimeout에 전달된 함수(콜백함수)가 루프 안에서 실행되지 않고 루프가 종료된 뒤 실행되었기 떄문이다.</li><li>즉, 루프가 종료되어 -1이 되기 전까지 콜백함수는 전혀 호출되지 않음(콜백함수 호출시점의 i는 -1)</li></ul></li><li>대안<ul><li><ol><li><code>let</code>을 사용하는 방법<ul><li>블록 수준 스코프를 사용하면 간단히 해결되지만 비동기적 프로그래밍에 대해 익숙해질 필요있음.</li></ul></li></ol></li><li><ol start="2"><li>함수를 하나 더 쓰는 방법<ul><li>함수를 하나 더 쓰면 스코프가 새롭게 생성되고 각 단계에서 i의 값이 클로저에 캡쳐된다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loopBody</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i===<span class="number">0</span> ? “go!” : i);</span><br><span class="line">    &#125;, (<span class="number">5</span>-i)*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">5</span>;i&gt;=<span class="number">0</span>;i—)&#123;loopBody(i);&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul></li></ul><p>이 경우 루프의 각 단계에서 loopBody 함수가 호출되고, JavaScript는 매개변수를 값으로 넘긴다. 즉, 루프의 각 단계에서 함수에 전달되는 것은 변수 i가 아니라 <code>i의 값</code>임. 중요한 것은 스코프가 7개 만들어졌고 변수도 7개가 만들어짐(하나는 외부스코프, 나머지 여섯은 loopBody를 호출할 때마다 생성되는 스코프)</p><ul><li><p>루프에 쓸 함수에 일일히 이름을 붙이는 것은 성가시므로, 익명함수를 만들고 이를 즉시실행함수로 처리가능(아래 코드)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&gt;=<span class="number">0</span>;i—)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i===<span class="number">0</span> ? “go!” : i);</span><br><span class="line">        &#125;, (<span class="number">5</span>-i)*<span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ES6의 블록스코프 변수선언 키워드 <code>let</code>을 사용하면 극도로 단순하게 처리가능</p><ul><li>JavaScript는 루프의 각 단계마다 변수 i의 복사본을 만들고, setTimeout에 전달한 함수가 실행될 때는 독립 스코프에서 변수를 받는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">5</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i===<span class="number">0</span> ? “go!” : i);</span><br><span class="line">    &#125;, (<span class="number">5</span>-i)*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>하지만 여기서도 let을 반복문(for 루프) 외부에 쓰면 같은 문제가 발생한다.</p><h2 id="13-6-변수로서의-함수"><a href="#13-6-변수로서의-함수" class="headerlink" title="13.6 변수로서의 함수"></a>13.6 변수로서의 함수</h2><ul><li>함수는 호출하였을 때 능동적이지만 호출하기 전엔 다른 변수와 마찬가지로 수동적</li><li>변수가 있을 수 있는 곳에 함수도 있을 수 있음<ul><li><ol><li>함수를 가리키는 변수를 반들어 별명을 정할 수 있음</li></ol></li><li><ol start="2"><li>배열에 함수를 넣을 수 있고, 다른 데이터와 섞일 수 있음</li></ol></li><li><ol start="3"><li>함수를 객체 프로퍼티로 사용할 수 있음</li></ol></li><li><ol start="4"><li>함수를 함수에 전달할 수 있음</li></ol></li><li><ol start="5"><li>함수가 함수를 반환할 수 있음</li></ol></li><li><ol start="6"><li>함수를 매개변수로 받는 함수를 반환하는 것도 가능</li></ol></li></ul></li><li>이런 유연성이 JavaScript 함수의 가장 강력한 특징이며 매우 자주 사용함</li></ul><h3 id="13-6-1-변수를-이용해-함수에-별명-붙이기"><a href="#13-6-1-변수를-이용해-함수에-별명-붙이기" class="headerlink" title="13.6.1 변수를 이용해 함수에 별명 붙이기"></a>13.6.1 변수를 이용해 함수에 별명 붙이기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>…<span class="title">z</span>(<span class="params">x</span>)</span>&#123;…&#125;</span><br><span class="line"><span class="keyword">const</span> f = abc…z; <span class="comment">// 이제 함수 abc…z는 f 함수로 호출 가능</span></span><br></pre></td></tr></table></figure><ul><li><code>const f1 = abc…z;</code>와 <code>const f2 = abc…z()</code>의 차이점은 전자는 함수에 별명을 붙인 것이고, 후자는 함수의 결과값을 f2변수에 할당한 것.</li><li>위 패턴은 노드 개발에서 자주 쓰이는 네임스페이스에서 계속 쓰는 패턴<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Money = <span class="built_in">require</span>(‘math-money’); <span class="comment">// require는 라이브러리를 불러오는 노드 함수</span></span><br><span class="line"><span class="keyword">const</span> oneDollar = Money.Dollar(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> Dollar = Money.Dollar;</span><br><span class="line"><span class="keyword">const</span> twoDollar = Dollar(<span class="number">2</span>); <span class="comment">// oneDollar와 twoDollar는 같은 타입의 인스턴스</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="13-6-2-배열-안의-함수"><a href="#13-6-2-배열-안의-함수" class="headerlink" title="13.6.2 배열 안의 함수"></a>13.6.2 배열 안의 함수</h3><ul><li>특정 상황에서 대단히 유용</li><li>자주 하는 일을 한 셋으로 묶는 파이프라인이 대표적</li><li>배열을 사용하면 작업 단계를 언제든 쉽게 바꿀 수 있다는 장점<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sin = <span class="built_in">Math</span>.sin;</span><br><span class="line"><span class="keyword">const</span> cos = <span class="built_in">Math</span>.cos;</span><br><span class="line"><span class="keyword">const</span> theta = <span class="built_in">Math</span>.PI/<span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> zoom = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> offset = [<span class="number">1</span>,<span class="number">-3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pipeline = [</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">retate</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            x: p.x * cos(theta) - p.y * sin(theta),</span><br><span class="line">            y: p.x * sin(theta) + p.y * cos(theta),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">scale</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">x</span>: p.x * zoom, <span class="attr">y</span>: p.y * zoom&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">x</span>: p.x + offset[<span class="number">0</span>], <span class="attr">y</span>: p.y + offset[<span class="number">1</span>] &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="comment">// 이제 pipeline은 2D 변형에 필요한 함수의 배열입니다.</span></span><br><span class="line"><span class="comment">// 점 하나를 변형해 봅시다.</span></span><br><span class="line"><span class="keyword">const</span> p = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> p2 = p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;pipeline.length;i++)&#123;</span><br><span class="line">    p2 = pipeline[i](p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p2는 이제 p1을 좌표 원점 기준으로 45도 회전하고(rotate)</span></span><br><span class="line"><span class="comment">// 원점에서 2 단위만큼 떨어뜨린 후(scale)</span></span><br><span class="line"><span class="comment">// 1단위 오른쪽, 3단위 아래쪽으로 움직인(translate) 점입니다.</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="13-6-3-함수에-함수-전달"><a href="#13-6-3-함수에-함수-전달" class="headerlink" title="13.6.3 함수에 함수 전달"></a>13.6.3 함수에 함수 전달</h3><ul><li>함수에 함수를 전달하는 다른 용도는 비동기적 프로그래밍. 이러한 용도로 전달하는 함수를 콜백함수라고 함(setTimeout, forEach 등)</li><li>콜백함수는 자신을 감싼 함수가 실행을 마쳤을 때 호출된다.</li><li>함수에 함수를 전달하는 대표적 사례가 콜백함수이지만 그것만 있는건 아님.</li><li>함수는 동작이고, 함수를 받은 함수는 그 동작을 활용할 수 있음.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr, f</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 함수가 전달되지 않았으면 매개변수를 그대로 반환하는 null 함수를 씁니다.</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> f != ‘<span class="function"><span class="keyword">function</span>’) <span class="title">f</span> = <span class="title">x</span> =&gt; <span class="title">x</span>;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">arr</span>.<span class="title">reduce</span>(<span class="params">(a,x</span>) =&gt; <span class="title">a</span> += <span class="title">f</span>(<span class="params">x</span>), 0);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">sum</span>(<span class="params">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span>);                     // 6</span></span><br><span class="line"><span class="function"><span class="title">sum</span>(<span class="params">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], x =&gt; x*x</span>)            // 14</span></span><br><span class="line"><span class="function"><span class="title">sum</span>(<span class="params">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], x =&gt; Math.pow(x,<span class="number">3</span></span>)); // 36</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="13-6-4-함수를-반환하는-함수"><a href="#13-6-4-함수를-반환하는-함수" class="headerlink" title="13.6.4 함수를 반환하는 함수"></a>13.6.4 함수를 반환하는 함수</h3><ul><li>난해하나 유용함</li><li>매개변수를 여러개 받는 함수를 하나만 받는 함수로 바꾸는 것을 커링(currying)이라고 함</li><li>express나 koa 같은 미들웨어 패키지가 함수를 반환하는 형태로 제작됨<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumOfSquares</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum(arr, x =&gt; x*x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 변수를 하나만 받도록 변경(currying)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newSummer</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arr</span> =&gt;</span> sum(arr, f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 새 함수 newSummer가 반환하는 함수는 단 하나의 매개변수만 받으면서도, 우리가 원하는 중간 함수를 마음대로 쓸 수 있음</span></span><br><span class="line"><span class="keyword">const</span> sumOfSquares = newSummer(<span class="function"><span class="params">x</span> =&gt;</span> x*x);</span><br><span class="line"><span class="keyword">const</span> sumOfCubes = newSummer(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">Math</span>.pow(x,<span class="number">3</span>));</span><br><span class="line">sumOfSquares([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);    <span class="comment">// returns 14</span></span><br><span class="line">sumOfCubes([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);      <span class="comment">// returns 36</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="13-7-재귀"><a href="#13-7-재귀" class="headerlink" title="13.7 재귀"></a>13.7 재귀</h3><ul><li>재귀: 자기 자신을 호출하는 함수</li><li>재귀함수에는 <code>종료조건</code>이 있어야 함</li><li>건초찾기와 계승(factorial) 찾기 예제</li></ul><h3 id="13-8-요약"><a href="#13-8-요약" class="headerlink" title="13.8 요약"></a>13.8 요약</h3><ul><li>함수형 언어(ML,하스켈,클로저,F# 등)에서 흔히 사용하는 함수형 사고방식</li><li>똑같은 일을 해도 방법은 다양함</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;13-1-서브루틴으로서의-함수&quot;&gt;&lt;a href=&quot;#13-1-서브루틴으로서의-함수&quot; class=&quot;headerlink&quot; title=&quot;13.1 서브루틴으로서의 함수&quot;&gt;&lt;/a&gt;13.1 서브루틴으로서의 함수&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;서브루틴&lt;ul&gt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://girin-dev.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://girin-dev.github.io/tags/ES6/"/>
    
      <category term="JavaScript" scheme="http://girin-dev.github.io/tags/JavaScript/"/>
    
      <category term="함수" scheme="http://girin-dev.github.io/tags/%ED%95%A8%EC%88%98/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript6 이터레이터와 제네</title>
    <link href="http://girin-dev.github.io/2019/01/03/ECMAScript6-iterator-generater/"/>
    <id>http://girin-dev.github.io/2019/01/03/ECMAScript6-iterator-generater/</id>
    <published>2019-01-03T04:49:35.000Z</published>
    <updated>2019-01-03T06:53:09.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="이터레이터"><a href="#이터레이터" class="headerlink" title="이터레이터"></a>이터레이터</h2><ul><li>이터레이터<ul><li>‘지금 어디 있는지’ 파악할 수 있도록 도움(책갈피)</li><li>iterable 객체(배열 등)에 <code>values 메서드</code>를 붙여 이터레이터 생성 가능</li><li>이후 이터레이터의 <code>next 메서드</code>로 읽을 수 있음</li><li><code>next 메서드</code>가 반환하는 객체</li></ul></li></ul><ol><li>value 프로퍼티(지금 보이는 페이지)</li><li>done 프로퍼티(마지막 페이지를 읽으면 true로 바뀌는)</li></ol><ul><li>중요한 점<ul><li>next에서 마지막 페이지를 반환했다고 해서 끝이 아님</li><li>더 진행할 것이 없으면 value는 <code>undefined</code>가 되지만 next는 계속 호출가능</li><li>이터레이터는 끝까지 진행했다면 뒤로 돌아가서 다른 데이터 제공 불가</li></ul></li><li>next 호출 중간에 다른 일 가능(<code>for 루프</code>/<code>for…of 루프</code> 가능)</li><li><code>for…of</code> =&gt; 이터레이터가 제공되면 무엇이든지 사용가능</li><li>이터레이터는 모두 독립적(새 이터레이터를 만들 때마다 처음에서 시작)</li></ul><h2 id="12-1-이터레이션-프로토콜"><a href="#12-1-이터레이션-프로토콜" class="headerlink" title="12.1 이터레이션 프로토콜"></a>12.1 이터레이션 프로토콜</h2><ul><li>이터레이터 프로토콜<ul><li>이터레이터는 더 쓸모있는 동작을 가능하게 함</li><li>이터레이터 프로토콜은 모든 객체를 이터러블 객체로 바꿀 수 있음</li><li>이터레이션 프로토콜은 <ul><li>클래스에 심볼메서드 <code>Symbol.interator</code>가 있고</li><li>이 메소드가 이터레이터처럼 동작하는 객체를 반환한다면</li><li>그 클래스의 인스턴스는 이터러블 객체라는 뜻</li></ul></li><li>이터레이터는 무한한 데이터에도 사용가능</li></ul></li></ul><h2 id="12-2-제너레이터"><a href="#12-2-제너레이터" class="headerlink" title="12.2 제너레이터"></a>12.2 제너레이터</h2><ul><li>제너레이터: 이터레이터를 사용해 자신의 실행을 제어하는 함수</li><li>일반적인 함수와 함수 호출자<ul><li>함수: 매개변수를 받고 값을 반환</li><li>호출자: 매개변수 말고는 딱히 함수실행 제어불가(함수를 호출하면 함수가 종료될 때까지 제어권이 넘어감)</li><li>그러나 제너레이터에선 다르다</li></ul></li><li>제너레이터에 도입된 신개념<ul><li>함수의 실행을 개별적 단계로 나누어 함수의 실행 제어</li><li>실행 중인 함수와 통신함</li></ul></li><li>일반적인 함수와의 차이(이 점을 빼면 일반함수와 동일)<ul><li>제너레이터는 <code>yield 키워드</code>를 통해 언제든 호출자에게 제어권을 넘길 수 있음</li><li>제너레이터는 호출 즉시 실행되는게 아니라 대신 이터레이터를 반환하고, 이터레이터의 <code>next 메서드</code>를 호출함에 따라 실행됨</li></ul></li><li>function 뒤에 애스터리스크(<code>*</code>)를 붙여 구분하고, <code>return</code> 외에 <code>yield</code> 키워드 사용가능</li><li>제너레이터를 호출하면 이터레이터를 얻는다. 함수 호출 뒤 이터레이터를 써서 단계별로 진행</li><li>제너레이터는 이터레이터를 반환하므로 <code>for…of 루프</code>에서 쓸 수 있음</li></ul><h3 id="12-2-1-yield-표현식과-양방향-통신"><a href="#12-2-1-yield-표현식과-양방향-통신" class="headerlink" title="12.2.1 yield 표현식과 양방향 통신"></a>12.2.1 yield 표현식과 양방향 통신</h3><ul><li>제너레이터와 호출자는 <code>yield 표현식</code>을 통해 양방향 통신이 가능</li><li><code>yield 표현식</code>의 값은 호출자가 제너레이터의 이터레이터에서 next를 호출할 때 제공하는 매개변수</li><li>제너레이터는 호출자가 정보를 전달하므로, 제너레이터는 그 정보에 따라 자신의 동작 자체를 바꿀 수 있다.(제너레이터는 화살표 함수로 만들 수 없고, 반드시 <code>function*</code>을 써야함)</li></ul><h3 id="12-2-2-제너레이터와-return"><a href="#12-2-2-제너레이터와-return" class="headerlink" title="12.2.2 제너레이터와 return"></a>12.2.2 제너레이터와 return</h3><ul><li><code>yield문</code>은 제너레이터의 마지막 문일지라도 제너레이터를 끝내지 않음</li><li>제너레이터는 return을 사용해야 그 위치에 관계없이 <code>done 프로퍼티</code>는 true가 되고, <code>value 프로퍼티</code>는 return이 반환하는 값이 된다.</li><li>제너레이터는 <code>done 프로퍼티</code>가 true이면 <code>value 프로퍼티</code>에 주의를 기울이지 않음</li><li>팁: 제너레이터에서 중요한 값을 return 시키지 말라. 제너레이터가 반환하는 값을 사용하려 할 때는 yield를 써야하고 return 제너레이터를 중간에 종료시키는 목적으로만 써야함. 즉, 제너레이터는 return을 쓸 때 반환값을 쓰지 않는 습관을 추천.</li></ul><h2 id="12-3-요약"><a href="#12-3-요약" class="headerlink" title="12.3 요약"></a>12.3 요약</h2><ul><li>이터레이터는 배열이나 객체처럼 여러가지 값을 제공할 수 있는 컬렉션의 동작방식을 표준화하였다.(패턴의 표준화)</li><li>제너레이터를 사용하면 함수를 훨씬 유연하고 효율적으로 사용가능.</li><li>제너레이터는 모든 연산을 지연시켰다가 필요한 순간에만 수행하게 할 수 있음.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;이터레이터&quot;&gt;&lt;a href=&quot;#이터레이터&quot; class=&quot;headerlink&quot; title=&quot;이터레이터&quot;&gt;&lt;/a&gt;이터레이터&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;이터레이터&lt;ul&gt;
&lt;li&gt;‘지금 어디 있는지’ 파악할 수 있도록 도움(책갈피)&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://girin-dev.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://girin-dev.github.io/tags/ES6/"/>
    
      <category term="JavaScript" scheme="http://girin-dev.github.io/tags/JavaScript/"/>
    
      <category term="iterator" scheme="http://girin-dev.github.io/tags/iterator/"/>
    
      <category term="generator" scheme="http://girin-dev.github.io/tags/generator/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript6 예외와 예외처리</title>
    <link href="http://girin-dev.github.io/2019/01/03/ECMAScript6-exception/"/>
    <id>http://girin-dev.github.io/2019/01/03/ECMAScript6-exception/</id>
    <published>2019-01-03T04:41:46.000Z</published>
    <updated>2019-01-03T04:48:13.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>예외와 예외처리<ul><li>에러 발생 가능성은 인정</li><li>에러를 예상하고 타당한 방법으로 처리</li></ul></li><li>예외처리(exception handling): 에러를 컨트롤하는 메커니즘</li><li><code>예상할 수 있는 에러</code>와 <code>예상치 못한 에러</code></li></ul><h2 id="11-1-Error-객체"><a href="#11-1-Error-객체" class="headerlink" title="11.1 Error 객체"></a>11.1 Error 객체</h2><ul><li><code>const err = new Error(‘invalid Error’);</code></li><li>내장된 Error 객체 활용해 에러메세지 지정 가능</li><li>252쪽 코드 구현해 볼 것</li></ul><h2 id="11-2-try-catch와-예외처리"><a href="#11-2-try-catch와-예외처리" class="headerlink" title="11.2 try/catch와 예외처리"></a>11.2 try/catch와 예외처리</h2><ul><li>뭔가를 시도(try)하고, 예외가 있으면 캐치(catch)함</li><li>이메일 주소를 받는 form에서 @를 빼먹는 것을 방지하는 것은 예상할 수 있는 에러이지만,</li><li>email에서 null 같은게 들어온다 등은 예상치 못한 에러</li><li>이때 <code>try…catch 문</code>을 사용<br>try {…실행부분} catch(err) {…에러감지시 실행}</li><li>즉, 에러를 캐치했다고 해서 프로그램이 멈추지 않고, 계속 진행되며 다만 에러를 기록함(문제가 해결된 건 아님)</li></ul><h2 id="11-3-에러-일으키기"><a href="#11-3-에러-일으키기" class="headerlink" title="11.3 에러 일으키기"></a>11.3 에러 일으키기</h2><ul><li>JavaScript는 에러가 일어날 때까지 기다릴 필요없이 직접 에러를 일으켜서(<code>throw</code>, <code>raise</code>) 예외처리 작업을 시작할 수 있음.</li><li>JavaScript는 에러를 일으킬 때, 꼭 객체만이 아니라 숫자, 문자열 등 어떤 값이든 catch절에 넘길 수 있음.(그러나 <code>Error 인스턴스</code>에 넘기는 것이 가장 편리함)</li><li><code>throw</code>를 호출하면 현재 함수는 즉시 실행을 멈춤.</li></ul><h2 id="11-4-예외처리와-호출스택"><a href="#11-4-예외처리와-호출스택" class="headerlink" title="11.4 예외처리와 호출스택"></a>11.4 예외처리와 호출스택</h2><ul><li>자바스크립트 인터프리터는 이런 과정을 모두 추적(스택에 차곡차곡)</li><li>호출스택: 완료되지 않은 함수가 쌓이는 것</li><li>에러는 캐치될 때까지 호출스택을 따라 올라감</li><li>에러는 호출스택 어디에서든 캐치가능, 어디에서도 캐치하지 않으면 자바스크립트 인터프리터는 프로그램을 멈춤<ul><li><code>unhandled</code> 예외(처리하지 않은), <code>uncaught</code> 예외(캐치하지 않은) =&gt; 프로그램 충돌의 원인</li></ul></li><li>에러를 캐치하면 호출스택에서 문제해결의 유용한 정보를 얻을 수 있다.</li><li><code>Error 인스턴스</code>에는 스택을 문자열로 표현한 <code>stack 프로퍼티</code> 존재(표준은 아니지만 대부분의 환경에서 지원)</li><li>255-256쪽 코드 참고(@가 있는 행은 스택추적)</li></ul><h2 id="11-5-try…catch…finally"><a href="#11-5-try…catch…finally" class="headerlink" title="11.5 try…catch…finally"></a>11.5 try…catch…finally</h2><ul><li>try 블록 코드가 HTTP연결파일과 같은 일종의 ‘자원’을 처리할 때가 있는데, 에러 여부와 관계없이 어느 시점에는 이 자원을 해제해야 할 때 <code>finally</code>를 써야 한다.</li><li>try 블록에 해제 구문을 쓴다면? <ul><li>try 블록 내에서 에러가 발생해 자원 해제의 기회를 잃을 수 있음</li></ul></li><li>catch 블록에 해제 구문을 쓴다면?<ul><li>에러가 발생하지 않으면 실행되지 않으니 해제의 기회가 없을 수 있음</li></ul></li><li>이때 필요한 것이 <code>finally 블록</code><ul><li>finally 블록은 에러가 일어나든 말든 반드시 호출.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;…&#125; <span class="keyword">catch</span>(err) &#123;…&#125; <span class="keyword">finally</span> &#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="11-6-요약"><a href="#11-6-요약" class="headerlink" title="11.6 요약"></a>11.6 요약</h2><ul><li>이제 모든 에러를 잡으려고 예상가능한 에러나 예상불가한 예외 중 어느 쪽이든 예외처리를 사용하고 싶을 것이나 예외처리는 비용이 요구됨<ul><li>예외를 캐치하지 못할 수 있음</li><li>예외처리 자체도 연산비용 소요</li></ul></li><li>예상할 수 없는 상황에 대한 마지노선 =&gt; 예외처리</li><li>예상할 수 있는 에러는 조건문으로 처리할 것을 추천</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;예외와 예외처리&lt;ul&gt;
&lt;li&gt;에러 발생 가능성은 인정&lt;/li&gt;
&lt;li&gt;에러를 예상하고 타당한 방법으로 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;예외처리(exception handling): 에러를 컨트롤하는 메커니즘&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://girin-dev.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://girin-dev.github.io/tags/ES6/"/>
    
      <category term="JavaScript" scheme="http://girin-dev.github.io/tags/JavaScript/"/>
    
      <category term="예외" scheme="http://girin-dev.github.io/tags/%EC%98%88%EC%99%B8/"/>
    
      <category term="예외처리" scheme="http://girin-dev.github.io/tags/%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript6 Map과 Set</title>
    <link href="http://girin-dev.github.io/2019/01/03/ECMAScript6-Map-Set/"/>
    <id>http://girin-dev.github.io/2019/01/03/ECMAScript6-Map-Set/</id>
    <published>2019-01-03T04:36:43.000Z</published>
    <updated>2019-01-03T04:41:03.060Z</updated>
    
    <content type="html"><![CDATA[<ul><li>맵: 객체와 비슷</li><li>셋: 배열과 비슷<h2 id="10-1-맵-Map"><a href="#10-1-맵-Map" class="headerlink" title="10.1 맵(Map)"></a>10.1 맵(Map)</h2></li><li>객체의 단점<ul><li>프로토타입 체인으로 의도치 않은 연결 생김</li><li>객체 안의 연결된 키와 값이 몇개나 되는지 쉽게 알 수 있는 방법이 없음</li><li>키는 심볼/문자열이어야 하므로, 객체를 키로 써서 값과 연결불가</li><li>객체는 프로퍼티 순서를 전혀 보장하지 않음</li></ul></li><li><p>Map</p><ul><li>이러한 결함을 모두 해결한 것으로 키-값 연결의 목적이라면 map이 객체보다 더 나은 선택<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> u1 = &#123;<span class="attr">name</span>:’Cynthia’&#125;;</span><br><span class="line"><span class="keyword">const</span> u2 = &#123;<span class="attr">name</span>:’Jackson’&#125;;</span><br><span class="line"><span class="keyword">const</span> u3 = &#123;<span class="attr">name</span>:’Olive’&#125;;</span><br><span class="line"><span class="keyword">const</span> u4 = &#123;<span class="attr">name</span>:’James’&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userRoles = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">userRoles.set(u1, ‘User’);</span><br><span class="line">userRoles.set(u2, ‘User’);</span><br><span class="line">userRoles.set(u3, ‘Admin’);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 표현방법1</span></span><br><span class="line"><span class="comment">// userRoles</span></span><br><span class="line"><span class="comment">//     .set(u1, ‘User')</span></span><br><span class="line"><span class="comment">//     .set(u2. ‘User’)</span></span><br><span class="line"><span class="comment">//     .set(u3. ‘Admin’)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 표현방법2</span></span><br><span class="line"><span class="comment">// const userRoles = new Map([</span></span><br><span class="line"><span class="comment">//     [u1, ‘User’], [u2, ‘User’], [u3, ‘Admin’],</span></span><br><span class="line"><span class="comment">// ]);</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>읽기</p><ul><li><p>존재하지 않는 키에 <code>get()</code> 호출시 undefined 반환</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userRoles.get(u2); <span class="comment">// “User"</span></span><br></pre></td></tr></table></figure></li><li><p><code>has()</code> 맵에 해당 키가 존재하는지 확인</p></li><li><code>set()</code> 쓰기. 이미 존재하는 키에 set()을 호출하면 값이 교체됨</li><li><code>size</code> 맵의 요소 숫자 반환</li><li><code>keys()</code> 맵의 키</li><li><code>values()</code> 값</li><li><code>entries()</code> 첫번째 요소가 키, 두번째 요소가 값인 배열 반환</li><li>keys(), values(), entries()는 모두 이터러블 객체이므로 <code>for…of 루프</code> 사용가능, 확산 연산자 활용해 배열로 변환가능</li><li><code>delete()</code> 맵의 요소 삭제</li><li><code>clear()</code> 맵의 요소 전체삭제</li></ul></li></ul><h2 id="10-2-위크맵-WeakMap"><a href="#10-2-위크맵-WeakMap" class="headerlink" title="10.2 위크맵(WeakMap)"></a>10.2 위크맵(WeakMap)</h2><ul><li>WeakMap은 다음 차이점을 빼면 Map과 완전히 동일<ul><li>키는 반드시 객체이어야 함</li><li>WeakMap의 키는 가비지콜렉션에 포함될 수 있음</li><li>WeakMap은 이터러블이 아니며 <code>clear()</code> 메서드가 없음<br>=&gt; 일반적으로 JavaScript에서는 코드 어딘가에서 객체를 참조하는 한 그 객체를 계속 메모리에 유지.(WeakMap은 가비지콜렉션 중인 객체를 노출할 가능성이 있기 때문에 이터러블이 될 수 없음)</li></ul></li><li>이런 특징으로 객체 인스턴스의 전용(private) 키를 저장하기에 알맞음.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SecretHolder = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> secrets = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">        setSecret(secret)&#123;</span><br><span class="line">            secrets.set(<span class="keyword">this</span>, secret);</span><br><span class="line">        &#125;</span><br><span class="line">        getSecret()&#123;</span><br><span class="line">            <span class="keyword">return</span> secrets.get(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ul><p>=&gt; WeakMap과 위크맵을 사용하는 클래스를 함께 IIFE에 넣었음. IIFE 외부에서는 그 인스턴스에 비밀스런 내용을 저장할 수 있는 SecretHolder라는 클래스를 얻음. 비밀저장(setSecret), 비밀조회(getSecret) 메서드<br>=&gt; Map을 써도 되지만 이 경우 저장내용이 가비지콜렉션에 포함되지 않음</p><h2 id="10-3-셋-Set"><a href="#10-3-셋-Set" class="headerlink" title="10.3 셋(Set)"></a>10.3 셋(Set)</h2><ul><li><p>셋: 중복을 허용하지 않는 데이터 집합</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> roles = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure></li><li><p>메소드와 프로퍼티</p><ul><li><code>add()</code> 요소 추가 (예시 - 사용자 역할 추가), 추가하려는 것이 셋에 이미 있는지 확인할 필요없으며 이미 있는 것을 추가하려하면 아무 일도 일어나지 않음</li><li><code>size</code> 배열의 length와 비슷</li><li><code>delete()</code> 요소 제거, 제거에 성공했다면(그런 요소가 셋에 존재했다면) <code>true</code> 반환 / 그렇지 않다면 <code>false</code> 반환</li></ul></li></ul><h2 id="10-4-위크셋-WeakSet"><a href="#10-4-위크셋-WeakSet" class="headerlink" title="10.4 위크셋(WeakSet)"></a>10.4 위크셋(WeakSet)</h2><ul><li>위크셋: 객체만 포함할 수 있으며, 이 객체들은 가비지콜렉션의 대상이 됨</li><li>이터러블 객체 아니며 그래서 용도가 적음</li><li>보통 위크셋의 실제 용도는 주어진 객체가 셋 안에 존재하는지 알아보는 것 정도.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;맵: 객체와 비슷&lt;/li&gt;
&lt;li&gt;셋: 배열과 비슷&lt;h2 id=&quot;10-1-맵-Map&quot;&gt;&lt;a href=&quot;#10-1-맵-Map&quot; class=&quot;headerlink&quot; title=&quot;10.1 맵(Map)&quot;&gt;&lt;/a&gt;10.1 맵(Map)&lt;/h2&gt;&lt;/
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://girin-dev.github.io/categories/JavaScript/"/>
    
    
      <category term="JavScript" scheme="http://girin-dev.github.io/tags/JavScript/"/>
    
      <category term="ES6" scheme="http://girin-dev.github.io/tags/ES6/"/>
    
      <category term="Map" scheme="http://girin-dev.github.io/tags/Map/"/>
    
      <category term="Set" scheme="http://girin-dev.github.io/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>Network-00-orientation</title>
    <link href="http://girin-dev.github.io/2018/04/16/Network-00-orientation/"/>
    <id>http://girin-dev.github.io/2018/04/16/Network-00-orientation/</id>
    <published>2018-04-16T13:56:23.000Z</published>
    <updated>2019-01-03T03:22:21.642Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Network/HTTP" scheme="http://girin-dev.github.io/categories/Network-HTTP/"/>
    
    
      <category term="네트워크" scheme="http://girin-dev.github.io/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"/>
    
  </entry>
  
  <entry>
    <title>Network-01-message</title>
    <link href="http://girin-dev.github.io/2018/04/16/Network-01-message/"/>
    <id>http://girin-dev.github.io/2018/04/16/Network-01-message/</id>
    <published>2018-04-16T13:38:06.000Z</published>
    <updated>2019-01-03T03:22:24.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="웹-브라우저가-메시지를-만든다"><a href="#웹-브라우저가-메시지를-만든다" class="headerlink" title="웹 브라우저가 메시지를 만든다"></a>웹 브라우저가 메시지를 만든다</h1><h2 id="01-HTTP-리퀘스트-메시지를-작성한다"><a href="#01-HTTP-리퀘스트-메시지를-작성한다" class="headerlink" title="01. HTTP 리퀘스트 메시지를 작성한다"></a>01. HTTP 리퀘스트 메시지를 작성한다</h2><ul><li><code>protocol</code> 쌍방간의 약속</li></ul><h3 id="http"><a href="#http" class="headerlink" title="http"></a><code>http</code></h3><ul><li><p>인터넷 통신 프로토콜, TCP/IP 의존적(더 깊은 layer)</p></li><li><p>Web에서 데이터를 주고 받기 위한 protocol로 요청과 응답이라는 쌍으로 이루어져있다.</p><ul><li>요청이 와야 응답이 오고, 요청이 없으면 응답도 없다.</li><li>무한 대기할 필요가 없으니 서버 부하가 적고, 이를 통해 http가 서버에 유리하게 설계되어 있음을 알 수 있다.</li><li>이러한 특성으로 서버 하나가 다량의 클라이언트를 상대할 수 있다.</li></ul></li><li>1요청에 1응답이 가능할 뿐이므로 상태를 유지할 수 없다.<code>stateless</code></li></ul><h3 id="URL과-URI"><a href="#URL과-URI" class="headerlink" title="URL과 URI"></a><code>URL</code>과 <code>URI</code></h3><ul><li><code>URL</code><ul><li>URL(Uniform/Universal Resource Locator)은 어디에서나 접근 가능한 장소(한정적)를 나타내는 말</li><li>http: ftp: file: mailto: 등 브라우저의 클라이언트 기능에 따라 다양하게 존재</li><li><code>protocol</code>과 <code>서버이름</code>, <code>리소스의 위치</code>로 구성</li><li>URL 마지막에 <code>/</code>를 생략해도 무관하며 이 경우 index.html 파일을 불러오거나 적절한 파일/디렉토리를 연다</li><li>URL 자체가 반드시 요청자의 바람대로 응답이 온다는 것을 보장하지 않는다. 응답은 전적으로 서버의 몫이며, 요청은 단순히 요청일 뿐이다.(W3C는 신뢰성을 위해 URL을 배포할 때 변화가 없는 것을 권장한다.)</li></ul></li><li><code>URI</code><ul><li>URI(Uniform/Universal Resource Identifier)로 URL보다 다양한 의미를 가지며 떄로 <code>URL</code>이 <code>URI</code>가 되기도 한다.</li></ul></li></ul><h3 id="요청메시지와-응답메시지"><a href="#요청메시지와-응답메시지" class="headerlink" title="요청메시지와 응답메시지"></a>요청메시지와 응답메시지</h3><ul><li>요청메시지<ul><li>요청 메시지 자체는 특별한 형식으로 작성되어 있다는 것을 내포하며, <code>헤더</code>, <code>바디</code>로 구성되어 있다.</li><li><code>메소드</code>는 URI와 함께 쓰여 요청메시지를 구성하며, 해당 메시지의 목적을 나타낸다.<ul><li>GET(받겠다)</li><li>POST(보내겠다)</li><li>HEAD(head만 보겠다)</li><li>OPTIONS(통신의 옵션을 통지/조사하겠다)</li><li>PUT(놓겠다/넣겠다)</li><li>DELETE(지정한 서버의 파일을 삭제하겠다)</li><li>TRACE(리퀘스트 라인과 헤더를 그대로 클라이언트에 반송한다)</li><li>CONNECT(암호화한 메시지를 프록시로 전송하겠다)</li></ul></li></ul></li><li>응답메시지<ul><li><code>응답코드</code>+<code>헤더</code>+<code>바디</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;웹-브라우저가-메시지를-만든다&quot;&gt;&lt;a href=&quot;#웹-브라우저가-메시지를-만든다&quot; class=&quot;headerlink&quot; title=&quot;웹 브라우저가 메시지를 만든다&quot;&gt;&lt;/a&gt;웹 브라우저가 메시지를 만든다&lt;/h1&gt;&lt;h2 id=&quot;01-HTTP-리
      
    
    </summary>
    
      <category term="Network/HTTP" scheme="http://girin-dev.github.io/categories/Network-HTTP/"/>
    
    
      <category term="네트워크" scheme="http://girin-dev.github.io/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"/>
    
  </entry>
  
  <entry>
    <title>CS 03. 실수(Real Number)</title>
    <link href="http://girin-dev.github.io/2018/03/12/CS-03-Real-Number/"/>
    <id>http://girin-dev.github.io/2018/03/12/CS-03-Real-Number/</id>
    <published>2018-03-12T07:47:30.000Z</published>
    <updated>2019-01-03T03:30:23.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="컴퓨터공학-실수"><a href="#컴퓨터공학-실수" class="headerlink" title="[컴퓨터공학] 실수"></a>[컴퓨터공학] 실수</h1><p>소수점의 등장<br>실수 표현은 표현 범위가 넓은 대신 정밀도가 낮다.</p><h2 id="1-실수-연산의-함정"><a href="#1-실수-연산의-함정" class="headerlink" title="1. 실수 연산의 함정"></a>1. 실수 연산의 함정</h2><p>컴퓨터로 소수점 계산을 하면 오류가 나는 경우가 있다.<br>가령 0.01을 10번 더하면 1을 기대하지만 실제 컴퓨터는 1.000000..007을 반환한다. 이것은 컴퓨터가 실수를 표현할 때, <code>부동소수점</code>을 이용하기 때문이다.</p><h2 id="2-부동소수점-floating-point"><a href="#2-부동소수점-floating-point" class="headerlink" title="2. 부동소수점(floating-point)"></a>2. 부동소수점(floating-point)</h2><p>실수는 같은 수라도 소수점의 위치에 따라 표현방식이 다양하다.</p><p>123.456<br>= 1.23456&#215;10<sup>2</sup><br>= 12.3456&#215;10<sup>1</sup><br>= 1234.56&#215;10<sup>-1</sup><br>= 12345.6&#215;10<sup>-2</sup>  </p><h2 id="3-단정도와-배정도"><a href="#3-단정도와-배정도" class="headerlink" title="3. 단정도와 배정도"></a>3. 단정도와 배정도</h2><ul><li>단정도<br>실수를 32bit(4byte)로 표혆하며 부호 1bit, 지수부 8bit, 가수부 23bit로 구성</li><li>배정도<br>실수를 64bit(8byte)로 표현하며 부호 1bit, 지수부 11bit, 가수부 52bit로 구성<br>파이썬에서 사용하는 방식으로 정밀도가 단정도보다 높음</li><li>파이썬의 부동소수점  <ul><li>배정도 부동소수점으로 표현할 수 있는 가장 큰 수(sys.float_info.max)<br><code>1.7976931348623157e+308</code></li><li>배정도 부동소수점으로 표현할 수 있는 가장 작은 수(sys.float_info.min)<br><code>2.2250738585072014e-308</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.float_info</span><br><span class="line">sys.float_info(max=<span class="number">1.7976931348623157e+308</span>, max_exp=<span class="number">1024</span>, max_10_exp=<span class="number">308</span>, min=<span class="number">2.2250738585072014e-308</span>, min_exp=<span class="number">-1021</span>, min_10_exp=<span class="number">-307</span>, dig=<span class="number">15</span>, mant_dig=<span class="number">53</span>,epsilon=<span class="number">2.220446049250313e-16</span>, radix=<span class="number">2</span>, rounds=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><!-- ## 4. 1바이트 실수 자료형 설계 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;컴퓨터공학-실수&quot;&gt;&lt;a href=&quot;#컴퓨터공학-실수&quot; class=&quot;headerlink&quot; title=&quot;[컴퓨터공학] 실수&quot;&gt;&lt;/a&gt;[컴퓨터공학] 실수&lt;/h1&gt;&lt;p&gt;소수점의 등장&lt;br&gt;실수 표현은 표현 범위가 넓은 대신 정밀도가 낮다.&lt;/p
      
    
    </summary>
    
      <category term="Computer Science" scheme="http://girin-dev.github.io/categories/Computer-Science/"/>
    
    
      <category term="컴퓨터공학" scheme="http://girin-dev.github.io/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99/"/>
    
      <category term="실수" scheme="http://girin-dev.github.io/tags/%EC%8B%A4%EC%88%98/"/>
    
  </entry>
  
  <entry>
    <title>CS 01. 정수(Integer)</title>
    <link href="http://girin-dev.github.io/2018/03/12/CS-02-Integer/"/>
    <id>http://girin-dev.github.io/2018/03/12/CS-02-Integer/</id>
    <published>2018-03-11T15:42:17.000Z</published>
    <updated>2019-01-03T03:30:22.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="컴퓨터공학-정수"><a href="#컴퓨터공학-정수" class="headerlink" title="[컴퓨터공학] 정수"></a>[컴퓨터공학] 정수</h1><p>0과 1만으로 표현하는 수(number), 양의 정수, 음의 정수</p><h2 id="1-컴퓨터에서-수를-표현하는-방법"><a href="#1-컴퓨터에서-수를-표현하는-방법" class="headerlink" title="1. 컴퓨터에서 수를 표현하는 방법"></a>1. 컴퓨터에서 수를 표현하는 방법</h2><ul><li>10진수</li><li>2진수</li><li>16진수<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-진수-변환"><a href="#2-진수-변환" class="headerlink" title="2. 진수 변환"></a>2. 진수 변환</h2><ul><li><p>10진수 &#8594; 2진수<br>25 = 16 + 8 + 1 = 1&#215;2<sup>4</sup> + 1&#215;2<sup>3</sup> + 0&#215;2<sup>2</sup> + 0&#215;2<sup>1</sup> + 1&#215;2<sup>0</sup><br>&#8594; <code>0b11001</code></p></li><li><p>2진수 &#8594; 10진수<br>11001 = 1&#215;2<sup>4</sup> + 1&#215;2<sup>3</sup> + 0&#215;2<sup>2</sup> + 0&#215;2<sup>1</sup> + 1&#215;2<sup>0</sup><br>&#8594; <code>25</code></p></li><li><p>16진수 &#8594; 2진수<br>16진수 한 자리는 2진수 네 자릿수까지 표현 가능  </p><ul><li>0~9까지는 10진수에서 2진수로 변환하는 법과 동일</li><li>a~f까지도 10진수 10~15를 2진수로 변환하는 것과 동일<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0xa = 0b1001</span><br><span class="line">0xb = 0b1011</span><br><span class="line">0xc = 0b1100</span><br><span class="line">0xd = 0b1101</span><br><span class="line">0xe = 0b1110</span><br><span class="line">0xf = 0b1111</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-양의-정수"><a href="#3-양의-정수" class="headerlink" title="3. 양의 정수"></a>3. 양의 정수</h2><p>1바이트 기준 설명(정수를 저장하는 크기로는 1, 2, 4, 8바이트가 존재)<br>1byte = 8bit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">양의 정수 25를 메모리에 저장해보기</span><br><span class="line"></span><br><span class="line">25 = 0b00011001</span><br><span class="line">0b뒤의 맨 앞 첫번째는 부호 결정(0 양수, 1 음수)</span><br><span class="line">빈 곳은 0으로 채우기</span><br><span class="line">나머지는 10진법 25를 2진법으로 변환한 것</span><br></pre></td></tr></table></figure></p><p>8비트로 나타낼 수 있는 수는 0~255가 아니라 -128~127까지(맨 앞의 자릿수는 부호로 처리하므로)</p><h2 id="4-음의-정수"><a href="#4-음의-정수" class="headerlink" title="4. 음의 정수"></a>4. 음의 정수</h2><p>컴퓨터가 음의 정수를 메모리에 저장할 때에 보수의 개념을 활용<br>보수 = 보충해주는 수<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3의 9의 보수 = (3을 더해 9가 되는 수) 6</span><br><span class="line">26의 9의 보수 = (26을 더해 99가 되는 수) 73</span><br></pre></td></tr></table></figure></p><ul><li>10의 보수: 9의 보수에서 1을 더하면 된다.</li><li><p>2의 보수<br>1의 보수에서 1을 더한 값</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2진수(0b)</span><br><span class="line">1010의 1의 보수 = (1010을 더해 1111이 되는 수) 0101</span><br><span class="line">1010의 2의 보수 = (1의 보수 0101에 1을 더한 수) 0110</span><br></pre></td></tr></table></figure></li><li><p>음수 표현<br>컴퓨터는 음수를 2의 보수를 이용해 저장한다.<br>음수 -4 표현</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2진수(0b)</span><br><span class="line">00000100(10진수 4(양수)의 2진법 표현)</span><br><span class="line">11111011(00000100의 1의 보수)</span><br><span class="line">11111100(11111011에 1을 더한 값)</span><br><span class="line">0xfc(11111100을 16진법으로 표현한 값)</span><br><span class="line">여기서 마지막 수 11111100로 -4를 표현한다.</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">-4</span>).to_bytes(<span class="number">1</span>, byteorder=<span class="string">"little"</span>, signed = <span class="keyword">True</span>)</span><br><span class="line"><span class="string">b'\xfc'</span></span><br></pre></td></tr></table></figure><ul><li>2의 보수로 표현하는 이유</li></ul><ol><li>양수와 음수를 모두 이미 양수를 표현하고 있는 방식으로 저장할 경우, 0을 표현하는 방식이 2가지가 된다.(+0, -0) 이것은 비트의 낭비이며 뺄셈에서 오류를 발생</li><li>컴퓨터는 빼기 계산을 할 때, 뺼셈을 따로 하는게 아니라 덧셈을 통해 계산하기 때문(9에서 4를 빼는게 아니라 9에서 (-4)를 더하는 개념)<br>이때 발생하는 반올림 수(1byte를 벗어난 1)는 버림처리한다.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;컴퓨터공학-정수&quot;&gt;&lt;a href=&quot;#컴퓨터공학-정수&quot; class=&quot;headerlink&quot; title=&quot;[컴퓨터공학] 정수&quot;&gt;&lt;/a&gt;[컴퓨터공학] 정수&lt;/h1&gt;&lt;p&gt;0과 1만으로 표현하는 수(number), 양의 정수, 음의 정수&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Computer Science" scheme="http://girin-dev.github.io/categories/Computer-Science/"/>
    
    
      <category term="컴퓨터공학" scheme="http://girin-dev.github.io/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99/"/>
    
      <category term="정수" scheme="http://girin-dev.github.io/tags/%EC%A0%95%EC%88%98/"/>
    
  </entry>
  
  <entry>
    <title>CS 01. 변수(Variable)</title>
    <link href="http://girin-dev.github.io/2018/03/11/CS-01-Variable/"/>
    <id>http://girin-dev.github.io/2018/03/11/CS-01-Variable/</id>
    <published>2018-03-11T09:16:46.000Z</published>
    <updated>2019-01-03T03:30:21.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="컴퓨터공학-01-변수"><a href="#컴퓨터공학-01-변수" class="headerlink" title="[컴퓨터공학] 01. 변수"></a>[컴퓨터공학] 01. 변수</h1><p>메모리와 데이터 위치를 가르키는 변수<br>변수와 참조의 개념 이해</p><h2 id="1-메모리-미리-보기"><a href="#1-메모리-미리-보기" class="headerlink" title="1. 메모리 미리 보기"></a>1. 메모리 미리 보기</h2><p>bit &lt; byte &lt; kilobyte &lt; megabyte &lt; gigabyte &lt; …<br>1024*1024 bit = 1024 byte = 1 kilobyte = …</p><h3 id="1-32비트와-64비트의-의미"><a href="#1-32비트와-64비트의-의미" class="headerlink" title="(1) 32비트와 64비트의 의미"></a>(1) 32비트와 64비트의 의미</h3><p>메모리 주소를 얼마나 표시할 수 있는지를 나타낸 표시<br>32비트 컴퓨터는 한번에 보낼 수 있는 데이터 개수가 32비트이고, 64비트 컴퓨터는 64비트이다.</p><h3 id="2-메모리-주소값-매기기"><a href="#2-메모리-주소값-매기기" class="headerlink" title="(2) 메모리 주소값 매기기"></a>(2) 메모리 주소값 매기기</h3><p>32비트가 나타낼 수 있는 주소의 갯수는 2e32개(2의 32제곱 = 4,294,967,296)이다. 이 때문에 32비트 컴퓨터는 메모리를 4GB이상 장착하더라도 인식할 수 없다.</p><h2 id="2-변수의-의미"><a href="#2-변수의-의미" class="headerlink" title="2. 변수의 의미"></a>2. 변수의 의미</h2><p>변수란 데이터를 저자알 수 있는 메모리 공간을 의미(단순한 이름이 아닌 메모리 공간 자체를 의미)<br>C언어의 경우 변수에 값이 담긴다.(파이썬은 이와 다름)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// num 이라는 '변수'에 5라는 '값'이 담겨있다.</span></span><br></pre></td></tr></table></figure></p><h2 id="3-파이썬에서의-변수"><a href="#3-파이썬에서의-변수" class="headerlink" title="3. 파이썬에서의 변수"></a>3. 파이썬에서의 변수</h2><p>`변수 = ‘이름’과 ‘값 객체’<br>C언어와 달리 이름은 값을 담고 있는 메모리 공간을 의미하는게 아니라 값 객체를 가리킬 뿐이다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">5</span></span><br><span class="line"><span class="comment"># num 이라는 '이름'이 5라는 '값 객체'를 가리킨다.(5라는 값을 담고 있는 메모리 공간을 의미하지 않음)</span></span><br><span class="line"><span class="comment"># num 이라는 변수의 타입은 상수가 아니라 int 라는 클래스의 인스턴스(객체)이다.</span></span><br></pre></td></tr></table></figure></p><h2 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h2><p>변수는 메모리와 밀접한 관련이 있으며 대입, 참조와 같은 개념과 연관있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;컴퓨터공학-01-변수&quot;&gt;&lt;a href=&quot;#컴퓨터공학-01-변수&quot; class=&quot;headerlink&quot; title=&quot;[컴퓨터공학] 01. 변수&quot;&gt;&lt;/a&gt;[컴퓨터공학] 01. 변수&lt;/h1&gt;&lt;p&gt;메모리와 데이터 위치를 가르키는 변수&lt;br&gt;변수와 
      
    
    </summary>
    
      <category term="Computer Science" scheme="http://girin-dev.github.io/categories/Computer-Science/"/>
    
    
      <category term="컴퓨터공학" scheme="http://girin-dev.github.io/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99/"/>
    
      <category term="메모리" scheme="http://girin-dev.github.io/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC/"/>
    
      <category term="변수" scheme="http://girin-dev.github.io/tags/%EB%B3%80%EC%88%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 13. 실행 컨텍스트와 자바스크립트의 동작 원리</title>
    <link href="http://girin-dev.github.io/2018/02/23/JavaScript-13-Execution-Context/"/>
    <id>http://girin-dev.github.io/2018/02/23/JavaScript-13-Execution-Context/</id>
    <published>2018-02-23T06:03:09.000Z</published>
    <updated>2018-02-24T06:49:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-13-실행-컨텍스트와-자바스크립트의-동작-원리"><a href="#JavaScript-13-실행-컨텍스트와-자바스크립트의-동작-원리" class="headerlink" title="JavaScript 13. 실행 컨텍스트와 자바스크립트의 동작 원리"></a>JavaScript 13. 실행 컨텍스트와 자바스크립트의 동작 원리</h1><h2 id="1-실행-컨텍스트-개념"><a href="#1-실행-컨텍스트-개념" class="headerlink" title="1. 실행 컨텍스트 개념"></a>1. 실행 컨텍스트 개념</h2><ul><li>정의(ECMAScript 기준)<ul><li>“실행 가능한 코드를 형상화하고 구분하는 추상적인 개념”</li><li>“실행 가능한 자바스크립트 코드 블록이 실행되는 환경”</li><li>다른 언어에서의 콜스택(함수의 호출 정보가 차곡차곡 쌓여있는 스택)에 들어가는 실행 정보 하나와 비슷</li></ul></li><li>실행가능한 코드<ul><li>전역코드</li><li>eval() 함수 코드</li><li>함수 안의 코드</li></ul></li></ul><h2 id="2-실행-컨텍스트의-3가지-객체"><a href="#2-실행-컨텍스트의-3가지-객체" class="headerlink" title="2. 실행 컨텍스트의 3가지 객체"></a>2. 실행 컨텍스트의 3가지 객체</h2><ul><li>변수객체(VO/Variable Object)</li><li>스코프체인(SC)</li><li>this value</li></ul><h3 id="1-변수객체-VO-Variable-Object"><a href="#1-변수객체-VO-Variable-Object" class="headerlink" title="(1) 변수객체(VO/Variable Object)"></a>(1) 변수객체(VO/Variable Object)</h3><ul><li>변수객체란 실행에 필요한 여러 정보들을 담는 객체</li><li>엔진에 의해 참조되지만 코드에 의해(사용자에 의해) 참조될 수는 없다.</li><li>VO가 담는 객체<ul><li>변수</li><li>매개변수와 인수정보</li><li>함수 선언식(함수 표현식은 제외, 함수 표현식은 변수의 방식으로 처리)</li></ul></li><li>VO는 실행 컨텍스트의 프로퍼티값으로 다른 객체를 가리키는데 경우에 따라 가리키는 값이 달라진다.<ol><li>전역 컨텍스트의 경우 <ul><li>VO는 유일하며 최상위에 위치하고 모든 전역 변수, 전역 함수 등을 포함하는 전역 객체(Global Object / GO)를 가리킨다.</li><li>전역 객체(GO)는 전역에 선언된 전역 변수와 전역 함수를 프로퍼티로 소유</li></ul></li><li>함수 컨텍스트의 경우<ul><li>VO는 Activation Object(AO / 활성 객체)를 가리키며 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 객체인 arguments object가 추가된다.</li></ul></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-13-실행-컨텍스트와-자바스크립트의-동작-원리&quot;&gt;&lt;a href=&quot;#JavaScript-13-실행-컨텍스트와-자바스크립트의-동작-원리&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 13. 실행 컨텍
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://girin-dev.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://girin-dev.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTML 02. HTML5 요소</title>
    <link href="http://girin-dev.github.io/2018/02/08/HTML-02-el-of-HTML5/"/>
    <id>http://girin-dev.github.io/2018/02/08/HTML-02-el-of-HTML5/</id>
    <published>2018-02-08T06:17:50.000Z</published>
    <updated>2018-03-07T17:04:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML5-요소"><a href="#HTML5-요소" class="headerlink" title="HTML5 요소"></a>HTML5 요소</h1><h2 id="1-문서를-구성하는-기본요소"><a href="#1-문서를-구성하는-기본요소" class="headerlink" title="1. 문서를 구성하는 기본요소"></a>1. 문서를 구성하는 기본요소</h2><h2 id="2-문서의-메타데이터"><a href="#2-문서의-메타데이터" class="headerlink" title="2. 문서의 메타데이터"></a>2. 문서의 메타데이터</h2><h2 id="3-스크립팅"><a href="#3-스크립팅" class="headerlink" title="3. 스크립팅"></a>3. 스크립팅</h2><h2 id="4-구조를-나타내는-요소"><a href="#4-구조를-나타내는-요소" class="headerlink" title="4. 구조를 나타내는 요소"></a>4. 구조를 나타내는 요소</h2><h3 id="1-lt-section-gt-콘텐츠-섹션"><a href="#1-lt-section-gt-콘텐츠-섹션" class="headerlink" title="(1) &lt;section&gt; 콘텐츠 섹션"></a>(1) <code>&lt;section&gt;</code> 콘텐츠 섹션</h3><ul><li>display <code>block</code></li><li><code>&lt;section&gt;</code>요소는 콘텐츠의 장과 절을 구분</li><li>반드시 <code>&lt;h1&gt;</code>과 같은 제목(heading tag)이 있어야 한다.</li><li><code>&lt;article&gt;</code>의 상위요소</li></ul><h3 id="2-lt-nav-gt-내비게이션"><a href="#2-lt-nav-gt-내비게이션" class="headerlink" title="(2) &lt;nav&gt; 내비게이션"></a>(2) <code>&lt;nav&gt;</code> 내비게이션</h3><ul><li>display <code>block</code></li><li>메인 메뉴나 서브 메뉴 등으로 링크 항목을 포함</li><li>남발하는 것을 지양하며 주요 내비게이션에만 사용해야 함</li></ul><h3 id="3-lt-article-gt-독립된-콘텐츠"><a href="#3-lt-article-gt-독립된-콘텐츠" class="headerlink" title="(3) &lt;article&gt; 독립된 콘텐츠"></a>(3) <code>&lt;article&gt;</code> 독립된 콘텐츠</h3><ul><li>display <code>block</code></li><li>내부에 <code>flow content</code>만을 포함할 수 있다.</li><li>완결성의 갖춘 하나의 콘텐츠를 담으며 RSS피드로 배포할 가치가 있는 독립된 콘텐츠.(포스트, 기사, 댓글, 글 등)</li><li><code>&lt;article&gt;</code>요소 안에 <code>&lt;article&gt;</code> 요소가 포함될 수 있으며 이 경우 논리적으로 부모자식관계의 <code>&lt;article&gt;</code>요소 콘텐츠는 관련이 있어야 한다.<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 부모자식 article --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 게시글과 댓글의 관계 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"ko"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>article 요소<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>책 그리고 커피와 함께한 생일<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>느즈막에 일어난 생일 아침. 요가로 몸을 풀어준 뒤 책 몇 권을 가방에 넣고...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>솔비<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">"2013-10-04T11:30:00+09:00"</span>&gt;</span>10월4일<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"reply"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>생일이셨군요 축하드립니다.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>미란다<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">time</span> <span class="attr">datatime</span>=<span class="string">"2013-10-05T11:35:00+09:00"</span>&gt;</span>10월5일<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-lt-aside-gt-본문-콘텐츠와-연관성이-적은-콘텐츠"><a href="#4-lt-aside-gt-본문-콘텐츠와-연관성이-적은-콘텐츠" class="headerlink" title="(4) &lt;aside&gt; 본문 콘텐츠와 연관성이 적은 콘텐츠"></a>(4) <code>&lt;aside&gt;</code> 본문 콘텐츠와 연관성이 적은 콘텐츠</h3><ul><li>display <code>block</code></li><li>메인 콘텐츠와 관계가 없는 사이드바나 광고 등을 포함(제작자의 의도에 따라 어떤 것이 관계가 없는 콘텐츠인가는 달라질 수 있음)</li></ul><h3 id="5-lt-header-gt-헤더"><a href="#5-lt-header-gt-헤더" class="headerlink" title="(5) &lt;header&gt; 헤더"></a>(5) <code>&lt;header&gt;</code> 헤더</h3><ul><li>display <code>block</code></li><li><code>&lt;header&gt;</code>요소와 <code>&lt;footer&gt;</code>요소를 자식으로 가질 수 없음</li><li><code>&lt;section&gt;</code>요소 내부에 있을 수 있으며 이 경우 해당 섹션의 헤더 콘텐츠.</li><li><code>&lt;h1&gt;</code>과 같은 헤딩 태그가 필수가 아님.</li></ul><h3 id="6-lt-footer-gt-푸터"><a href="#6-lt-footer-gt-푸터" class="headerlink" title="(6) &lt;footer&gt; 푸터"></a>(6) <code>&lt;footer&gt;</code> 푸터</h3><ul><li>display <code>block</code></li><li>연락처와 저작권 등을 포함</li></ul><h3 id="7-lt-adress-gt-사이트-연락처-정보"><a href="#7-lt-adress-gt-사이트-연락처-정보" class="headerlink" title="(7) &lt;adress&gt; 사이트 연락처 정보"></a>(7) <code>&lt;adress&gt;</code> 사이트 연락처 정보</h3><ul><li>display <code>block</code></li><li>모든 주소가 아니라 해당 페이지 또는 포스트의 관리자/게시자의 연락처, 주소 정보</li></ul><h3 id="8-lt-h1-gt-lt-h6-gt-콘텐츠-제목"><a href="#8-lt-h1-gt-lt-h6-gt-콘텐츠-제목" class="headerlink" title="(8) &lt;h1&gt;~&lt;h6&gt; 콘텐츠 제목"></a>(8) <code>&lt;h1&gt;~&lt;h6&gt;</code> 콘텐츠 제목</h3><ul><li>display <code>block</code></li><li>요소의 제목으로 <code>&lt;section&gt;</code> 안에 반드시 들어가야 한다.</li></ul><h2 id="5-그룹"><a href="#5-그룹" class="headerlink" title="5. 그룹"></a>5. 그룹</h2><h3 id="1-lt-div-gt-콘텐츠-그룹화"><a href="#1-lt-div-gt-콘텐츠-그룹화" class="headerlink" title="(1) &lt;div&gt; 콘텐츠 그룹화"></a>(1) <code>&lt;div&gt;</code> 콘텐츠 그룹화</h3><ul><li>display <code>block</code></li><li>의미를 갖고 있지 않은 콘텐츠 블록</li></ul><h3 id="2-lt-main-gt-주요-콘텐츠"><a href="#2-lt-main-gt-주요-콘텐츠" class="headerlink" title="(2) &lt;main&gt; 주요 콘텐츠"></a>(2) <code>&lt;main&gt;</code> 주요 콘텐츠</h3><ul><li>display <code>block</code></li><li>HTML5, <code>&lt;body&gt;</code> 요소 내에서 한번만 사용되어야 함</li><li>사이드바나 검색 영역을 그룹화해서는 안 됨</li></ul><h3 id="3-lt-p-gt-단락"><a href="#3-lt-p-gt-단락" class="headerlink" title="(3) &lt;p&gt; 단락"></a>(3) <code>&lt;p&gt;</code> 단락</h3><ul><li>display <code>block</code></li><li><code>Phrasing content</code>를 포함</li></ul><h3 id="4-lt-ul-gt-비순서형-목록과-lt-ol-gt-순서형-목록"><a href="#4-lt-ul-gt-비순서형-목록과-lt-ol-gt-순서형-목록" class="headerlink" title="(4) &lt;ul&gt; 비순서형 목록과 &lt;ol&gt; 순서형 목록"></a>(4) <code>&lt;ul&gt;</code> 비순서형 목록과 <code>&lt;ol&gt;</code> 순서형 목록</h3><ul><li>display <code>block</code></li><li>자식요소는 <code>&lt;li&gt;</code>만 가능</li><li><code>&lt;ol&gt;</code> 순서형 목록의 경우 <code>start</code>, <code>reversed</code>라는 어트리뷰트를 추가하여 각각 시작 숫자를 정하거나 순서를 오름차순, 내림차순으로 지정할 수 있음.<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> 하나</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> 둘</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> 셋</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> 넷</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 5, 6, 7, 8 순으로 렌더링  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">reversed</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> 하나</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> 둘</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> 셋</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> 넷</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1, 2, 3, 4가 아니라 4, 3, 2, 1  --&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-lt-figure-gt-lt-figcaption-gt-콘텐츠-포함을-위한-그룹과-캡션"><a href="#5-lt-figure-gt-lt-figcaption-gt-콘텐츠-포함을-위한-그룹과-캡션" class="headerlink" title="(5) &lt;figure&gt;, &lt;figcaption&gt; 콘텐츠 포함을 위한 그룹과 캡션"></a>(5) <code>&lt;figure&gt;</code>, <code>&lt;figcaption&gt;</code> 콘텐츠 포함을 위한 그룹과 캡션</h3><ul><li>display <code>block</code></li><li>HTML5, 이미지/비디오/오디오 등을 포함 <code>&lt;figure&gt;</code></li><li>해당 콘텐츠의 캡션을 달 때 사용 <code>&lt;figcaption&gt;</code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/chocolate_museum.jpg"</span> <span class="attr">alt</span>=<span class="string">"중세기사의 조형물로 장식된 초콜릿 박물관 입구"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>세계 10대 초콜릿 박물관 입구<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-lt-blockquote-gt-인용문"><a href="#6-lt-blockquote-gt-인용문" class="headerlink" title="(6) &lt;blockquote&gt; 인용문"></a>(6) <code>&lt;blockquote&gt;</code> 인용문</h3><ul><li>display <code>block</code></li><li>어트리뷰트 <code>cite</code>의 경우 웹사이트는 URL, 책의 경우 ISBN을 값으로 줄 수 있음</li></ul><h3 id="7-lt-pre-gt"><a href="#7-lt-pre-gt" class="headerlink" title="(7) &lt;pre&gt;"></a>(7) <code>&lt;pre&gt;</code></h3><ul><li>display <code>block</code></li><li>마크다운에서 `<code>작성된 코드 `</code> 과 비슷하며 공백과 줄바꿈 등을 입력한 그대로 브라우저 화면에 표현하고자 할 때 사용</li></ul><h3 id="8-lt-hr-gt"><a href="#8-lt-hr-gt" class="headerlink" title="(8) &lt;hr&gt;"></a>(8) <code>&lt;hr&gt;</code></h3><ul><li>display <code>block</code></li><li>HTML5에서는 디자인을 위한 수평선이 아니라 주제가 바뀌는, 즉 단락 구분을 위해 사용</li><li>섹션 구분에 사용하면 안 되며, 섹션을 구분하기 위한 구분선을 CSS로 따로 작업을 해야함.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML5-요소&quot;&gt;&lt;a href=&quot;#HTML5-요소&quot; class=&quot;headerlink&quot; title=&quot;HTML5 요소&quot;&gt;&lt;/a&gt;HTML5 요소&lt;/h1&gt;&lt;h2 id=&quot;1-문서를-구성하는-기본요소&quot;&gt;&lt;a href=&quot;#1-문서를-구성하는-기본요
      
    
    </summary>
    
      <category term="HTML/CSS" scheme="http://girin-dev.github.io/categories/HTML-CSS/"/>
    
    
      <category term="HTML" scheme="http://girin-dev.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>180206~180208-TIL</title>
    <link href="http://girin-dev.github.io/2018/02/06/180206-180208-TIL/"/>
    <id>http://girin-dev.github.io/2018/02/06/180206-180208-TIL/</id>
    <published>2018-02-06T14:04:10.000Z</published>
    <updated>2018-03-07T16:55:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="180206-180208-TIL"><a href="#180206-180208-TIL" class="headerlink" title="180206~180208 TIL"></a>180206~180208 TIL</h1><h2 id="한-일"><a href="#한-일" class="headerlink" title="한 일"></a>한 일</h2><h3 id="1-JavaScript"><a href="#1-JavaScript" class="headerlink" title="1. JavaScript"></a>1. JavaScript</h3><h4 id="Inside-JavaScript"><a href="#Inside-JavaScript" class="headerlink" title="[Inside JavaScript]"></a>[Inside JavaScript]</h4><ul><li>Function과 this 파트 보강</li><li><code>apply()</code>와 <code>call()</code></li><li>함수 리턴</li></ul><h3 id="2-Python-Django-Reviewer"><a href="#2-Python-Django-Reviewer" class="headerlink" title="2. Python Django Reviewer"></a>2. <a href="https://github.com/girin-dev/python-Django-reviewer" target="_blank" rel="noopener">Python Django Reviewer</a></h3><ul><li><a href="https://github.com/girin-dev/python-Django-reviewer/commit/62bc38e040dec08c0d771e940fd0208601bba835" target="_blank" rel="noopener">3-2. 흐름 제어 (If, for, while)</a></li><li><a href="">4-1. 데이터 구조(Dictionary, set), tuple(list comprehension)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;180206-180208-TIL&quot;&gt;&lt;a href=&quot;#180206-180208-TIL&quot; class=&quot;headerlink&quot; title=&quot;180206~180208 TIL&quot;&gt;&lt;/a&gt;180206~180208 TIL&lt;/h1&gt;&lt;h2 id=&quot;한-일&quot;&gt;
      
    
    </summary>
    
      <category term="TIL" scheme="http://girin-dev.github.io/categories/TIL/"/>
    
    
      <category term="TIL(Today I Learned)" scheme="http://girin-dev.github.io/tags/TIL-Today-I-Learned/"/>
    
  </entry>
  
  <entry>
    <title>180201~180205-TIL</title>
    <link href="http://girin-dev.github.io/2018/02/02/180201-180205-TIL/"/>
    <id>http://girin-dev.github.io/2018/02/02/180201-180205-TIL/</id>
    <published>2018-02-02T04:55:05.000Z</published>
    <updated>2018-02-07T12:54:21.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="180201-180205-TIL"><a href="#180201-180205-TIL" class="headerlink" title="180201~180205 TIL"></a>180201~180205 TIL</h1><h2 id="한-일"><a href="#한-일" class="headerlink" title="한 일"></a>한 일</h2><h3 id="1-Python-Django-Reviewer"><a href="#1-Python-Django-Reviewer" class="headerlink" title="1. Python Django Reviewer"></a>1. <a href="https://github.com/girin-dev/python-Django-reviewer" target="_blank" rel="noopener">Python Django Reviewer</a></h3><ul><li>파이썬의 모든 자료형은 객체다.</li><li>파이썬과 자바스크립트의 차이를 알아가는 것도 재미있다.</li><li><a href="https://github.com/girin-dev/python-Django-reviewer/commit/62bc38e040dec08c0d771e940fd0208601bba835" target="_blank" rel="noopener">2-2. Type과 연산(Numbers, String, boolean), 데이터 구조( List)</a><h3 id="2-JavaScript"><a href="#2-JavaScript" class="headerlink" title="2. JavaScript"></a>2. JavaScript</h3><h4 id="1-Inside-JavaScript"><a href="#1-Inside-JavaScript" class="headerlink" title="(1) [Inside JavaScript]"></a>(1) [Inside JavaScript]</h4></li><li>함수호출과 this</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;180201-180205-TIL&quot;&gt;&lt;a href=&quot;#180201-180205-TIL&quot; class=&quot;headerlink&quot; title=&quot;180201~180205 TIL&quot;&gt;&lt;/a&gt;180201~180205 TIL&lt;/h1&gt;&lt;h2 id=&quot;한-일&quot;&gt;
      
    
    </summary>
    
      <category term="TIL" scheme="http://girin-dev.github.io/categories/TIL/"/>
    
    
      <category term="TIL(Today I Learned)" scheme="http://girin-dev.github.io/tags/TIL-Today-I-Learned/"/>
    
  </entry>
  
  <entry>
    <title>Joy님의 특강</title>
    <link href="http://girin-dev.github.io/2018/01/29/SL-howtoStudy(Joy)/"/>
    <id>http://girin-dev.github.io/2018/01/29/SL-howtoStudy(Joy)/</id>
    <published>2018-01-29T11:02:57.000Z</published>
    <updated>2019-01-03T03:23:06.300Z</updated>
    
    <content type="html"><![CDATA[<!-- # Joy님의 특강 --><p>FDS5기 수료생 Joy Kim님의 특강<br>(<a href="https://github.com/feel5ny" target="_blank" rel="noopener">https://github.com/feel5ny</a>)</p><h2 id="1-How-to-Study"><a href="#1-How-to-Study" class="headerlink" title="1. How to Study"></a>1. How to Study</h2><p><code>그때그때하기</code></p><h3 id="1-이해-amp-정리"><a href="#1-이해-amp-정리" class="headerlink" title="(1) 이해 &amp; 정리"></a>(1) 이해 &amp; 정리</h3><ul><li>너무 deep하지 않게</li><li>형식적인 정리말고 이해를 해서 스스로 정리</li><li>러버덕(스스로 말할 수 있을 정도)까지하면 최선</li></ul><h3 id="2-체화"><a href="#2-체화" class="headerlink" title="(2) 체화"></a>(2) 체화</h3><ul><li>그 주의 이해가 안되는 부분을 주단위로 주말 체화</li><li>프레임워크, 라이브러리는 인터넷 번역과 나만의 요약(그림)으로 하는게 좋았던 것 같음.</li></ul><h2 id="2-Project"><a href="#2-Project" class="headerlink" title="2. Project"></a>2. Project</h2><ul><li>욕심 부리지 말기</li><li>완성도 있는 결과물과 협업 능력을 목표로 하자</li><li>견고한 초반 기획(전체 메뉴 구조, 와이어프레임, 컨셉, 디자인)</li><li>문서화를 꼼꼼히 하는 습관(선례 <a href="https://github.com/huusz/Da-Da/blob/master/README.md" target="_blank" rel="noopener">https://github.com/huusz/Da-Da/blob/master/README.md</a>)</li><li>추천 CSS 프레임워크<ul><li>Ant design</li><li>Semantic UI</li></ul></li><li>디자인 팁<ul><li>툴 - 스케치, invision, zeplin</li><li>고퀄사진, 메인배경은 영상처리, 굵은 영문 타이포(Google font-Open Sans, Lato), 한글 타이포(스포카 한 산스/노트산스)</li></ul></li></ul><h2 id="3-협업능력"><a href="#3-협업능력" class="headerlink" title="3. 협업능력"></a>3. 협업능력</h2><h3 id="1-코드-컨벤션-초반에-꼭-정하기"><a href="#1-코드-컨벤션-초반에-꼭-정하기" class="headerlink" title="(1) 코드 컨벤션 초반에 꼭 정하기"></a>(1) 코드 컨벤션 초반에 꼭 정하기</h3><ul><li>class명, 카멜케이스, 플러그인(prettier, lint 등)</li></ul><h3 id="2-깃-git"><a href="#2-깃-git" class="headerlink" title="(2) 깃 git"></a>(2) 깃 git</h3><ul><li>깃 branch 컨벤션도 정하면 굳(git flow 참고)</li></ul><h3 id="3-Github"><a href="#3-Github" class="headerlink" title="(3) Github"></a>(3) Github</h3><ul><li>issue와 Pull Request 활용</li></ul><h3 id="4-칸반보드-trello-같은거"><a href="#4-칸반보드-trello-같은거" class="headerlink" title="(4) 칸반보드(trello 같은거)"></a>(4) 칸반보드(trello 같은거)</h3><h2 id="4-이후"><a href="#4-이후" class="headerlink" title="4. 이후"></a>4. 이후</h2><h3 id="1-이론"><a href="#1-이론" class="headerlink" title="(1) 이론"></a>(1) 이론</h3><h3 id="2-실습"><a href="#2-실습" class="headerlink" title="(2) 실습"></a>(2) 실습</h3><ul><li>토이프로젝트</li><li>블로그</li></ul><h3 id="3-네트워크-외부행사"><a href="#3-네트워크-외부행사" class="headerlink" title="(3) 네트워크(외부행사)"></a>(3) 네트워크(외부행사)</h3><ul><li>다니는 것도 좋은데 스텝으로도 해보면 의외의 기회가 나올 수 있음(구직)</li></ul><h2 id="추천책"><a href="#추천책" class="headerlink" title="추천책"></a>추천책</h2><ul><li><a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=26434671" target="_blank" rel="noopener">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- # Joy님의 특강 --&gt;
&lt;p&gt;FDS5기 수료생 Joy Kim님의 특강&lt;br&gt;(&lt;a href=&quot;https://github.com/feel5ny&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/fee
      
    
    </summary>
    
      <category term="ETC" scheme="http://girin-dev.github.io/categories/ETC/"/>
    
    
  </entry>
  
  <entry>
    <title>HTML 01. 새로운 표준, HTML5</title>
    <link href="http://girin-dev.github.io/2018/01/29/HTML-01-HTML5/"/>
    <id>http://girin-dev.github.io/2018/01/29/HTML-01-HTML5/</id>
    <published>2018-01-29T07:45:01.000Z</published>
    <updated>2018-02-16T08:13:51.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HMTL의-탄생"><a href="#HMTL의-탄생" class="headerlink" title="HMTL의 탄생"></a>HMTL의 탄생</h1><ul><li>HTML5 이전<ul><li>W3C의 XHTML 1.0과 XHTML 2.0(2.0은 기존 웹의 하위 호환성을 고려하지 않아 이후 폐기)</li><li>콘텐츠의 표시의 역할이 강조되던 시기</li><li>어플리케이션의 필요한 부분은 Flash나 Silver light, Active X 등을 통해 구현하였으나 브라우저별 호환성 이슈와 플러그인 강제설치 등의 이슈가 발생</li></ul></li><li>WHATWG(Web Hypertext Application Technology Working Group, Apple/Mozila/Opera 등)<ul><li>W3C의 XHTML 2.0에 반대하여 결성</li><li>Web Application 1.0, Web Forms 2.0</li></ul></li><li>W3C가 XHTML 2.0을 포기하고 WHATWG의 권고안을 받아들이면서 HTML5 탄생</li></ul><hr><h1 id="HTML4-01-XHTML-1-0과-HTML5의-차이점"><a href="#HTML4-01-XHTML-1-0과-HTML5의-차이점" class="headerlink" title="HTML4.01, XHTML 1.0과 HTML5의 차이점"></a>HTML4.01, XHTML 1.0과 HTML5의 차이점</h1><h2 id="1-콘텐츠-모델"><a href="#1-콘텐츠-모델" class="headerlink" title="1. 콘텐츠 모델"></a>1. 콘텐츠 모델</h2><ul><li>인라인요소와 블록요소(기존 HTML 기반 마크업) 이외에 명확한 정보 구조 설계와 구성을 위해 카테고리를 정의하여 각 요소별로 비슷한 성격을 가지고 있는 것끼리 그룹화한 것.</li><li><p>구조와 구성을 중시하는 마크업으로 진화한 것.</p><h3 id="1-섹셔닝-루트-Sectioning-Root"><a href="#1-섹셔닝-루트-Sectioning-Root" class="headerlink" title="1. 섹셔닝 루트(Sectioning Root)"></a>1. 섹셔닝 루트(Sectioning Root)</h3></li><li>장이나 절과 같은 계층 구조로 구분되지 않고 독립적인 콘텐츠로 분리</li><li><p>아웃라인에 영향을 주지 않음  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span> <span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">detail</span>&gt;</span> <span class="tag">&lt;/<span class="name">detail</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span> <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span> <span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-메타데이터-콘텐츠-Metadata-Content"><a href="#2-메타데이터-콘텐츠-Metadata-Content" class="headerlink" title="2. 메타데이터 콘텐츠(Metadata Content)"></a>2. 메타데이터 콘텐츠(Metadata Content)</h3></li><li><p>문서의 정보를 포함하는 <code>메타데이터</code>, 스타일 표현을 위한 <code>&lt;style&gt;</code> 요소, 행동을 설정하는 <code>&lt;script&gt;</code> 요소 등을 나타냄</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-플로우-콘텐츠-Flow-Content"><a href="#3-플로우-콘텐츠-Flow-Content" class="headerlink" title="3. 플로우 콘텐츠(Flow Content)"></a>3. 플로우 콘텐츠(Flow Content)</h3></li><li><code>메타데이터 콘텐츠</code> 요소 중 일부를 제외하고 문서 본문에 해당하는 body 요소에 들어가는 대부분의 요소</li><li><p><code>&lt;area&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;style&gt;&lt;/style&gt;</code> 요소는 조건부로 플로우 콘텐츠</p><h3 id="4-섹셔닝-콘텐츠-Sectioning-Content"><a href="#4-섹셔닝-콘텐츠-Sectioning-Content" class="headerlink" title="4. 섹셔닝 콘텐츠(Sectioning Content)"></a>4. 섹셔닝 콘텐츠(Sectioning Content)</h3></li><li>섹셔닝 콘텐츠는 대부분 HTML5에 새롭게 추가된 요소</li><li>제목과 그 내용을 포함한 범위를 지정하는 콘텐츠 표시</li><li><p>헤딩과 아웃라인을 가짐</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span> <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span> <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span> <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span> <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-헤딩-콘텐츠-Heading-Content"><a href="#5-헤딩-콘텐츠-Heading-Content" class="headerlink" title="5. 헤딩 콘텐츠(Heading Content)"></a>5. 헤딩 콘텐츠(Heading Content)</h3></li><li><p>세션의 제목을 나타내며 문서의 아웃라인을 고려해서 사용해야 함</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>, <span class="tag">&lt;<span class="name">h2</span>&gt;</span>, <span class="tag">&lt;<span class="name">h3</span>&gt;</span>, <span class="tag">&lt;<span class="name">h4</span>&gt;</span>, <span class="tag">&lt;<span class="name">h5</span>&gt;</span>, <span class="tag">&lt;<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-프레이징-콘텐츠-Phrasing-Content"><a href="#6-프레이징-콘텐츠-Phrasing-Content" class="headerlink" title="6. 프레이징 콘텐츠(Phrasing Content)"></a>6. 프레이징 콘텐츠(Phrasing Content)</h3></li><li>문서의 텍스트 지칭하며 문단의 내부 레벨로 마크업하는 요소 / 문단의 구성 요소</li><li><code>&lt;a&gt;</code> 처럼 콘텐츠로 다른 요소를 포함하지 않는 경우에 한해 조건부 프레이징 콘텐츠가 되는 요소도 존재</li><li>대부분 <code>플로우 콘텐츠</code> 전체를 포함할 수 없으며 프레이징 콘텐츠로 분류된 요소만을 포함할 수 있음.</li><li><p>텍스트 이외에도 <code>임베디드 콘텐츠</code>를 포함할 수 있음</p><h3 id="7-임베디드-콘텐츠-Embeded-Content"><a href="#7-임베디드-콘텐츠-Embeded-Content" class="headerlink" title="7. 임베디드 콘텐츠(Embeded Content)"></a>7. 임베디드 콘텐츠(Embeded Content)</h3></li><li>문서 안에 외부 자원(외부 리소스)나 HTML이 아닌 다른 언어의 콘텐츠를 표현</li><li><p>이미지, 동영상, 플로그인, iframe 등과 MathML, SVG 등</p><h3 id="8-인터렉티브-콘텐츠-Interactive-Content"><a href="#8-인터렉티브-콘텐츠-Interactive-Content" class="headerlink" title="8. 인터렉티브 콘텐츠(Interactive Content)"></a>8. 인터렉티브 콘텐츠(Interactive Content)</h3></li><li>사용자가 어떤 기능을 조작할 수 있는 (상호 작용 가능한) 콘텐츠</li><li><p><code>&lt;audio&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;object&gt;</code>, <code>&lt;video&gt;</code>의 경우 조건부 인터렉티브 콘텐츠</p><h3 id="9-팰퍼브-콘텐츠-Palpable-Content"><a href="#9-팰퍼브-콘텐츠-Palpable-Content" class="headerlink" title="9. 팰퍼브 콘텐츠(Palpable Content)"></a>9. 팰퍼브 콘텐츠(Palpable Content)</h3></li><li>새롭게 추가된 개념으로 구체적으로 보여지고 이해할 수 있는 콘텐츠 요소(?)</li><li><p>최소 하나 이상의 요소가 존재해야 함.(숨김 상태이면 안 됨)</p><h3 id="10-스크립트-지원-요소-Script-supporting-Elements"><a href="#10-스크립트-지원-요소-Script-supporting-Elements" class="headerlink" title="10. 스크립트 지원 요소(Script-supporting Elements)"></a>10. 스크립트 지원 요소(Script-supporting Elements)</h3></li><li>요소 자체는 어떤 정보를 표현하지 않음</li><li><p>스크립트 지원</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="11-트랜스-패어런트-콘텐츠-Transparent-Content"><a href="#11-트랜스-패어런트-콘텐츠-Transparent-Content" class="headerlink" title="11. 트랜스 패어런트 콘텐츠(Transparent Content)"></a>11. 트랜스 패어런트 콘텐츠(Transparent Content)</h3></li><li>콘텐츠 모델을 가지지만, 앞에서 설명한 카테고리에 속하지 않은 경우</li><li><p>트랜스 패어런트 콘텐츠 요소와 그 안에 담긴 콘텐츠를 바꾸어 마크업해도 HTML5 문법 오류가 없음</p><h2 id="2-아웃라인-알고리즘-Outline-Algorithm"><a href="#2-아웃라인-알고리즘-Outline-Algorithm" class="headerlink" title="2. 아웃라인 알고리즘(Outline Algorithm)"></a>2. 아웃라인 알고리즘(Outline Algorithm)</h2><h3 id="1-gg"><a href="#1-gg" class="headerlink" title="1. gg"></a>1. gg</h3></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HMTL의-탄생&quot;&gt;&lt;a href=&quot;#HMTL의-탄생&quot; class=&quot;headerlink&quot; title=&quot;HMTL의 탄생&quot;&gt;&lt;/a&gt;HMTL의 탄생&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;HTML5 이전&lt;ul&gt;
&lt;li&gt;W3C의 XHTML 1.0과 XHTML 2
      
    
    </summary>
    
      <category term="HTML/CSS" scheme="http://girin-dev.github.io/categories/HTML-CSS/"/>
    
    
      <category term="HTML" scheme="http://girin-dev.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>북스터디 04. 객체지향의 사실과 오해</title>
    <link href="http://girin-dev.github.io/2018/01/21/Book-01-TEOO-180121/"/>
    <id>http://girin-dev.github.io/2018/01/21/Book-01-TEOO-180121/</id>
    <published>2018-01-21T13:14:08.000Z</published>
    <updated>2019-01-03T03:30:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="북스터디-1번째"><a href="#북스터디-1번째" class="headerlink" title="북스터디 1번째"></a>북스터디 1번째</h1><p><a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=60550259" target="_blank" rel="noopener">객체지향의 사실과 오해</a></p><p><a href="https://github.com/girin-dev/zhuzi" target="_blank" rel="noopener">스터디 레포 zhuzi</a></p><h2 id="협력하는-객체들의-공동체"><a href="#협력하는-객체들의-공동체" class="headerlink" title="협력하는 객체들의 공동체"></a>협력하는 객체들의 공동체</h2><ul><li>객체지향은 현실세계를 반영하려고 한 것이라고 생각하기 쉬운데 반은 맞고 반은 틀리다.<h2 id="이상한-나라의-객체"><a href="#이상한-나라의-객체" class="headerlink" title="이상한 나라의 객체"></a>이상한 나라의 객체</h2></li></ul><h2 id="타입의-추상화"><a href="#타입의-추상화" class="headerlink" title="타입의 추상화"></a>타입의 추상화</h2><h2 id="역할-책임-협력"><a href="#역할-책임-협력" class="headerlink" title="역할, 책임, 협력"></a>역할, 책임, 협력</h2><ul><li>협력<br>협력의 본질은 요청과 응답으로 연결되는 사람(객체)들의 네트워크<br>요청을 받은 객체는 응답의 의무가 있음<br>즉, 협력에 참여하는 객체가 수행할 책임이 바로 요청과 응답</li><li>책임<ul><li>“객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것” [Larman 2004]<ul><li>공용 인터페이스, 캡슐화</li></ul></li><li>책임의 분류<ul><li>하는 것(doing)<br>외부에 제공해 줄 수 있는 서비스<ul><li>객체를 생성하거나 계산을 하는 등의 스스로 하는 것</li><li>다른 객체의 행동을 시작시키는 것</li><li>다른 객체의 활동을 제어하고 조절하는 것</li></ul></li><li>아는 것(knowing)<br>외부에 제공해 줄 수 있는 정보<ul><li>개인적인 정보에 관해 아는 것</li><li>관련된 객체에 관해 아는 것</li><li>자신이 유도하거나 계산할 수 있는 것에 관해 아는 것</li></ul></li></ul></li><li>메시지<ul><li>객체 간의 협력을 이루어지게 하는 것</li><li>객체가 다른 객체에 접근할 수 있는 유일한 방법</li><li>책임은 메시지의 상위 개념(하나의 책임이 여러 메시지로 분할)</li></ul></li><li>객체지향 설계는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터 메시지를 수신할 것인지를 결정하는 것으로부터 시작.</li></ul></li><li>역할<ul><li>역할은 재사용 가능하고 유연한 객체지향 설계를 낳는 중요한 구성요소</li><li>중요한 것은 협력이지 객체 그 자체가 아니고, 역할은 협력 내에서 다른 객체로 대체할 수 있다는 일종의 표식.</li><li>협력의 추상화와 단순화를 가능케 함.</li><li>역할은 협력 안에서의 구체적 객체로 대체될 수 있는 추상적 협력자(대체가능성, 행위호환성, 동일한 책임의 수행)</li></ul></li><li>객체의 모양을 결정하는 협력<ul><li>흔한 오류<ol><li>시스템에 필요한 데이터를 저장하기 위해 객체가 존재한다?<ul><li>객체는 행위를 수행하기 위한 재료일 뿐</li></ul></li><li>객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다?<ul><li>클래스는 시스템에 필요한 객체를 표현하고 생성하기 위한 구현 메커니즘일 뿐</li></ul></li></ol></li><li>협력을 따라 흐르는 객체의 책임<ul><li>견고하고 깔끔한 협력 설계, 객체간의 요청과 응답의 흐름 결정</li><li>행동을 결정한 후에 그 행동을 수행하기 위한 데이터 고민</li><li>행동과 데이터를 고민한 이후에 객체들을 구현할 클래스를 고민</li><li>설계 -&gt; 행위에 기반한 협력 -&gt; 책임 분배</li></ul></li></ul></li><li>객체지향 설계 기법<ol><li>책임-주도 설계<ul><li>협력에 필요한 책임들을 식별하고 적합한 객체에 책임을 할당하는 방식 </li><li>개별적 객체의 상태가 아닌 객체의 책임과 상호작용에 집중한다.</li><li>절차 <ol><li>시스템이 사용자에게 제공해야 하는 기능, 즉 시스템 책임 파악</li><li>시스템 책임을 더 작은 책임으로 분할</li><li>분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당</li><li>객체가 책임을 수행하는 중 다른 객체읟 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾음</li><li>해당 객체 또는 역할에게 책임을 할당하여 두 객체가 협력</li></ol></li></ul></li><li>디자인 패턴<ul><li>전문가들이 반복적으로 사용하는 해결 방법을 정의해 놓은 설계 템플릿 모음.</li><li>반복적으로 발생하는 문제와 해결책의 조합</li><li>COMPOSITE 패턴</li></ul></li><li>테스트-주도 개발<ul><li>테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성해가는 방식(설계를 위한 기법)</li><li>기본 흐름은 실패하는 테스트를 작성하고, 테스트를 통과하는 가장 간단한 코드를 작성한 후 리팩토링을 통해 중복을 제거하는 것.</li><li>중요한 건 테스트가 아니라 책임 수행의 객체/클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것.</li><li>객체지향에 대한 깊이 있는 지식 요구.</li></ul></li></ol></li></ul><h2 id="모으기"><a href="#모으기" class="headerlink" title="모으기"></a>모으기</h2><ul><li>개념관점과 명세관점, 구현관점 -&gt; 객체지향</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;북스터디-1번째&quot;&gt;&lt;a href=&quot;#북스터디-1번째&quot; class=&quot;headerlink&quot; title=&quot;북스터디 1번째&quot;&gt;&lt;/a&gt;북스터디 1번째&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.aladin.co.kr/shop/wproduct
      
    
    </summary>
    
      <category term="Computer Science" scheme="http://girin-dev.github.io/categories/Computer-Science/"/>
    
    
      <category term="books" scheme="http://girin-dev.github.io/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>180118-TIL</title>
    <link href="http://girin-dev.github.io/2018/01/18/180118-TIL/"/>
    <id>http://girin-dev.github.io/2018/01/18/180118-TIL/</id>
    <published>2018-01-18T14:38:09.000Z</published>
    <updated>2018-01-18T14:50:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="오늘-한-일"><a href="#오늘-한-일" class="headerlink" title="오늘 한 일"></a>오늘 한 일</h2><ul><li>독서스터디<ul><li>&lt;객체지향의 사실과 오해: 역할, 책임, 협력 관점에서 본 객체지향&gt;</li><li>4장 “역할, 책임, 협력” 읽는 중</li></ul></li><li>TypeScript Meetup 참석<ul><li>관련 내용 정리</li><li>huiseoul이라는 회사를 알게 됨</li></ul></li></ul><h2 id="huiseoul"><a href="#huiseoul" class="headerlink" title="huiseoul"></a>huiseoul</h2><p>  huiseoul이라는 회사의 작업방식과 지원자격은 앞으로 개발자로서의 공부방식 등에 본보기가 될 것 같아 따로 기록을 남긴다.<br>  또한 해당 레포를 포크떠놨다. 두고두고 참고해야지.</p><ul><li><p>huiseoul의 작업방식</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>좋은 엔지니어는 좋은 습관이 만든다고 생각합니다.</span><br><span class="line"><span class="bullet">- </span>좋은 습관을 만들기 위해 노력합니다.</span><br><span class="line">  - 매일 오전 10시에 daily meeting 을 통해 한 일 / 할 일 / 도움이 필요한 부분을 공유합니다.</span><br><span class="line">  - [<span class="string">Peer Review</span>](<span class="link">https://engineering.huiseoul.com/pr-peer-review-pull-request-d301399f6a17</span>) 로 자신의 코드를 공유합니다.</span><br><span class="line">  - 지속적인 배포와 test code 로 작성한 코드에 대한 책임감을 요구합니다.</span><br><span class="line">  - [<span class="string">Prettier</span>](<span class="link">https://github.com/prettier/prettier</span>), [<span class="string">TSLint</span>](<span class="link">https://github.com/palantir/tslint</span>) 로 format quality 를 유지합니다.</span><br><span class="line">  - 2주마다의 sprint 회고를 통해서 팀을 돌아보고 더 나아질 수 있는 부분을 점검합니다.</span><br><span class="line"><span class="bullet">- </span>좋은 엔지니어는 끊임없이 배워야 합니다.</span><br><span class="line"><span class="bullet">- </span>더 나은 기술을 찾고 이를 끊임없이 적용합니다.</span><br><span class="line">  - 신기술만을 쫓는 hype driven development 는 하지 않습니다.</span><br><span class="line">  - 과거의 기술에 매달려 있어서도 안 됩니다.</span><br><span class="line">  - 기술을 열린 태도로, 비판적으로 받아들입니다.</span><br><span class="line">  - 모든 엔지니어는 일주일에 한번 기존의 코드를 더 낫게 만드는 방법에 관해서 팀원을 대상으로 발표합니다.</span><br><span class="line"><span class="bullet">- </span>스타트업 엔지니어가 얻을 수 있는 가장 큰 보상은 성장입니다.</span><br><span class="line">  - 지금까지 쭉 성장해왔고, 앞으로 더 빠르게 성장할 것입니다.</span><br><span class="line">  - 위의 기술 stack 을 안정적으로 production 에 적용한 손꼽는 곳입니다.</span><br><span class="line">  - 팀 사이즈가 아직 작아, 욕심내는 모든 부분에 참여할 수 있습니다.</span><br><span class="line"><span class="bullet">- </span>성장에는 고통이 따릅니다.</span><br><span class="line">  - 자신의 업무결과를 가능한 투명하게 드러냅니다.</span><br><span class="line">  - 발전하는 기술과, 늘어나는 요구조건, 성장하는 기술 스택에 적응하는 것은 개인의 능력 / 노력에 달려있습니다.</span><br></pre></td></tr></table></figure></li><li><p>huiseoul의 지원자격</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>기본 조건</span><br><span class="line">  - Typescript(at least javascript ES2015) 로 문제풀이가 가능하신 분</span><br><span class="line">  - 간단한 test case 를 작성할 수 있으신 분 (library 무관)</span><br><span class="line">  - Github 에 계정이 있으며 자신의 코드를 남과 공유해본 경험이 있으신 분</span><br><span class="line">  - Internet browser 에 주소를 입력하고 엔터를 쳤을 때부터 화면이 뜨기까지의 과정을 5분 이상 설명하실 수 있는 분</span><br><span class="line">  - 한글 문서와 영어 문서를 읽는 데 걸리는 시간 차이가 30% 안쪽이신 분</span><br><span class="line">  - 한국인 팀 동료와의 의사소통에 문제가 없으신 분</span><br><span class="line"><span class="bullet">- </span>우대 조건</span><br><span class="line">  - React, React Native, GraphQL 중 한 가지 이상의 기술이 적용된 서비스 제작 및 운영에 메인으로 참여하신 분</span><br><span class="line">  - React component 의 layout 및 styling 에 자신 있으신 분</span><br><span class="line">  - Written communication 에 익숙하신 분</span><br><span class="line">  - Open source 프로젝트에 기여하신 경험이 있는 분</span><br><span class="line"><span class="bullet">- </span>특별 우대 조건</span><br><span class="line">  - 실력과 노력과 배움에 자신이 있으신 분</span><br><span class="line"><span class="code">    - 이 경우 위의 조건들은 무시하셔도 됩니다.</span></span><br><span class="line"><span class="bullet">- </span>지원 분야</span><br><span class="line">  - (당분간은) 기본적으로 full stack 을 지향합니다.</span><br><span class="line">  - 정말 커다란 회사가 아닌 이상 엔지니어가 대부분의 흐름을 파악해야 한다고 생각하기 때문입니다.</span><br><span class="line">  - 풀어야 하는 문제가 점점 복잡하고 커질수록 특정 분야의 전문성이 필요하다고 생각합니다.</span><br><span class="line">  - 하지만 frontend or backend 에 더 깊은 관심을 가지고 있고 잘할 수 있는 분이라면 업무 분야를 한정해서 지원해주셔도 좋습니다.</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;오늘-한-일&quot;&gt;&lt;a href=&quot;#오늘-한-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 한 일&quot;&gt;&lt;/a&gt;오늘 한 일&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;독서스터디&lt;ul&gt;
&lt;li&gt;&amp;lt;객체지향의 사실과 오해: 역할, 책임, 협력 관점에서 
      
    
    </summary>
    
      <category term="TIL" scheme="http://girin-dev.github.io/categories/TIL/"/>
    
    
      <category term="TIL(Today I Learned)" scheme="http://girin-dev.github.io/tags/TIL-Today-I-Learned/"/>
    
  </entry>
  
  <entry>
    <title>180118-TypeScript_Meetup</title>
    <link href="http://girin-dev.github.io/2018/01/18/Conf-TypeScript-Meetup(180118)/"/>
    <id>http://girin-dev.github.io/2018/01/18/Conf-TypeScript-Meetup(180118)/</id>
    <published>2018-01-18T10:04:22.000Z</published>
    <updated>2019-01-03T03:30:21.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-Meetup"><a href="#TypeScript-Meetup" class="headerlink" title="TypeScript Meetup"></a>TypeScript Meetup</h1><h2 id="손찬욱님-NAVER-TypeScript로부터-얻은-것과-잃은-것"><a href="#손찬욱님-NAVER-TypeScript로부터-얻은-것과-잃은-것" class="headerlink" title="손찬욱님 (NAVER) - TypeScript로부터 얻은 것과 잃은 것"></a>손찬욱님 (NAVER) - TypeScript로부터 얻은 것과 잃은 것</h2><ul><li>egjs, 다형성, <a href="https://naver.github.io/egjs-axes/" target="_blank" rel="noopener">eg.Axes</a></li><li>TypeScript를 도입하기 전까지<ul><li>인터페이스를 이용하면 좋았을텐데</li><li>다양한 인터페이스(좌표이동, 손가락 오무리기, 마우스 휠 등) 를 지원하고 싶다.</li></ul></li><li>얻은 것<ul><li><ol><li>코드 설계 의도가 분명</li></ol><ul><li>definition 파일이 자동으로 생서</li></ul></li><li><ol start="2"><li>안정성</li></ol><ul><li>툴의 도움을 받을 수 있음</li></ul></li><li><ol start="3"><li>편의성</li></ol><ul><li>codeAssist, 코드 이동(추적)</li><li>map, reduce 등을 동시에 여러번 적용하게 될 때 인자들에 대한 타입을 지정해줄 수 있다. =&gt; 데이터의 변형과 전달의 흐름 추적에 용이.(안정성)</li><li>lodash, rxjs와의 케미도 좋음.</li></ul></li><li>이 밖에도 ES3까지 지원되는 TypeScript 위엄.</li></ul></li><li>잃은 것<ul><li><ol><li>서드파티 라이브러리 사용할 때</li></ol><ul><li>서드파티 라이브러리가 UMD, CommonJS 형식으로 만들어진 모듈의 경우 ES6 Module이라는 표준형식으로 호출시 호출이 안되는 상황이 발생(?)</li><li><code>import * as \___ from &quot;___.js&quot;</code>, <code>import \___ from &quot;___.js&quot;</code></li><li>그나마 다행인 것은 최근 라이브러리들은 ES6 Module 용도 함께 배포</li></ul></li><li><ol start="2"><li>서드파티 라이브러리 @types 사용 시</li></ol><ul><li>외부 type definition 파일이 완벽하지 않음</li><li>서드파티 라이브러리 내부의 타입들을 다룰때 아예 타입을 재정의해버려야 하는 경우가 발생.</li></ul></li><li><ol start="3"><li>과한 사용은 오히려 독!</li></ol><ul><li>과도한 타입설정과 표시는 가독성을 해침.</li></ul></li></ul></li><li>결론<ul><li>장점: 코드의 명확, 주석없이 명세화 가능, 안전성, 편의성, ES3 지원</li><li>단점: 외부 모듈 사용이 불편(TypeScript 사용 환경이 아직 덜 보급), 과한 사용이 가독성을 떨어뜨림.</li><li>하지만 이 단점들이 대개 기존 시스템과의 이질감과 미진한 보급에서 비롯. 장점을 살려서 적절히 사용해보도록 해보아요~^^</li></ul></li></ul><hr><h2 id="김상원님-Tumblbug-코드-한-줄-없는-Typescript-사용기"><a href="#김상원님-Tumblbug-코드-한-줄-없는-Typescript-사용기" class="headerlink" title="김상원님 (Tumblbug) - 코드 한 줄 없는 Typescript 사용기"></a><a href="http://vichyssoise.io/" target="_blank" rel="noopener">김상원님</a> (Tumblbug) - 코드 한 줄 없는 Typescript 사용기</h2><ul><li>TypeScript: JavaScript의 offset(=superset).</li><li>TypeScript가 준 신뢰<ul><li>기억이 안나도 과거의 코드를 믿을 수 있게 되었다.</li><li><ol><li>빠른 디버깅</li></ol></li><li><ol start="2"><li>코드의 양이 줄어듦</li></ol></li><li><ol start="3"><li>코드 자체가 문서가 됨</li></ol></li><li><ol start="4"><li>팀원간의 신뢰도를 높여줌. 정해진 규칙, 즉 타입을 공유하고 있기 때문.</li></ol></li></ul></li><li>TypeScript가 준 실망<ul><li>세팅: 빌드 프로세스 수립 과정이 복잡</li><li><code>[변수] as any</code> =&gt; 해당 변수의 type을 무시. Type system의 장점을 희석시키지만 어쩔 수 없이 써야 하는 상황이 발생</li><li>코드와 타입이 불일치</li></ul></li></ul><hr><h2 id="한승호님-에멘탈-Typescript-개발-문화"><a href="#한승호님-에멘탈-Typescript-개발-문화" class="headerlink" title="한승호님 (에멘탈) - Typescript 개발 문화"></a>한승호님 (에멘탈) - Typescript 개발 문화</h2><h3 id="타입스크립트-도입을-위한-넓고-얕은-지식"><a href="#타입스크립트-도입을-위한-넓고-얕은-지식" class="headerlink" title="타입스크립트 도입을 위한 넓고 얕은 지식"></a>타입스크립트 도입을 위한 넓고 얕은 지식</h3><ul><li>Generic과 Decorator(를 활용한 깔끔한 Data Model)을 잘 활용하고 있음.</li><li>서버 관련해서 <a href="https://hapijs.com/" target="_blank" rel="noopener">hapi</a>라는게 있어요. express도 물론 있고.</li><li>타입스크립트로 백엔드도 구성할 수 있는 신세계가 있군요!</li><li><p>egghead.io/ typescriptlang.org/play/</p></li><li><p>사실 무슨 말을 하고 있는건지 이해하지 못함. </p></li><li>Node.js? 백엔드 기준으로 하고 있는 듯함.</li><li>백엔드에서 타입스크립트는 Node.js에서의 한계가 보이며 DevOps 구축시에도 손이 많이간다.</li></ul><hr><h2 id="최종욱님-후이서울-트릴리어네어-React-with-Typescript"><a href="#최종욱님-후이서울-트릴리어네어-React-with-Typescript" class="headerlink" title="최종욱님 (후이서울(트릴리어네어)) - React with Typescript"></a><a href="https://github.com/johnwook" target="_blank" rel="noopener">최종욱님</a> (후이서울(트릴리어네어)) - React with Typescript</h2><ul><li>React는 킹왕짱이에요.<ul><li>GraphQL이 뭐지..?</li><li>리엑트와 뷰js는 달라요. 리엑트는 선언적이고 효율적이며 어디든 적용할 수 있는 유연함을 갖고 있어요. </li></ul></li><li>TypeScript는 리엑트와 함께^^<ul><li>관련 레포(<a href="https://github.com/johnwook/ts-meetup-2018-1" target="_blank" rel="noopener">https://github.com/johnwook/ts-meetup-2018-1</a>)</li><li>interface를 정의하고 그를 따르는 것은 생각보다 큰 차이를 만들어낸다.</li><li>아마도… 코드와 컴포넌트에 대한 사전 설계에 대해 스스로 명확하게 인식한 이후 코딩을 할 수 있다는 게 그 차이가 아닐까 싶다. </li></ul></li><li>타입스크립트의 장점<ul><li>함수를 자기묘사를 할 수 있게끔 하고</li><li>인터페이스를 먼저 정의하고 이에 집중하게 한다.</li></ul></li><li>말 잘하고 재치가 있는 분인 듯</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TypeScript-Meetup&quot;&gt;&lt;a href=&quot;#TypeScript-Meetup&quot; class=&quot;headerlink&quot; title=&quot;TypeScript Meetup&quot;&gt;&lt;/a&gt;TypeScript Meetup&lt;/h1&gt;&lt;h2 id=&quot;손찬욱님-
      
    
    </summary>
    
      <category term="ETC" scheme="http://girin-dev.github.io/categories/ETC/"/>
    
    
      <category term="Conference" scheme="http://girin-dev.github.io/tags/Conference/"/>
    
      <category term="TypeScript" scheme="http://girin-dev.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>패스트캠퍼스 프론트엔드 스쿨 6기 후기</title>
    <link href="http://girin-dev.github.io/2017/12/17/review-FC/"/>
    <id>http://girin-dev.github.io/2017/12/17/review-FC/</id>
    <published>2017-12-16T17:53:55.000Z</published>
    <updated>2019-01-03T04:58:11.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="패스트캠퍼스-프론트엔드-스쿨-6기-솔직-후기"><a href="#패스트캠퍼스-프론트엔드-스쿨-6기-솔직-후기" class="headerlink" title="패스트캠퍼스 프론트엔드 스쿨 6기 솔직 후기"></a>패스트캠퍼스 프론트엔드 스쿨 6기 솔직 후기</h1><p>패스트캠퍼스 프론트엔드 스쿨 6기를 다니고 있는 girin-dev입니다. 현재 반려동물을 관리하는 웹 어플리케이션 프로젝트를 진행하고 있습니다. 지난 4개월간 패스트캠퍼스를 다니면서 느꼈던 바와 패스트캠퍼스를 선택하게 된 이유와 과정과 솔직한 후기를 공유하고자 합니다.<br>학원이나 기관 등 프로그래밍 도움을 받고자 하는 많은 분들에게 좋은 정보가 되기를 바랍니다.</p><p>비전공자로서 프로그래밍을 배우는 것에 여러 어려움이 있었습니다. 특히 단순히 취미로 하는 코딩이 아니라 전문 개발자로서 커리어를 시작하려고 하지만, 내게 무엇이 필요하고 지금 무엇이 부족한지 정확히 알기가 어려웠습니다. 프로그래밍을 전혀 안 해본 것은 아니지만, 또 뭐 딱히 안다고도 할 수 없는 것이 바로 4개월 전의 제 상태였습니다. 이런 상황에서 벗어나고자 여러 방법을 찾고 있었고 패스트캠퍼스도 선택지 중 하나였습니다.</p><p>사실 예전과 달리 요즘은 패스트캠퍼스 뿐만 아니라 프로그래밍을 가르치는 다양한 기관과 학원이 존재하고, 또 여러 스터디가 시시각각 조직되고 있습니다. 이건 사실 좋은 환경이기도 하지만 너무 많은 선택지로 인해 혼란을 주기도 합니다. 제가 선택했던 과정과 배제되었던 다른 기관들은 어떤 이유에서였는지 말씀드리겠습니다.</p><h2 id="왜-패스트캠퍼스를-선택하게-되었나"><a href="#왜-패스트캠퍼스를-선택하게-되었나" class="headerlink" title="왜 패스트캠퍼스를 선택하게 되었나?"></a>왜 패스트캠퍼스를 선택하게 되었나?</h2><p><img src="/img/fc-logo.png" alt="ex_screenshot"></p><h3 id="최신-기술을-반영한-커리큘럼"><a href="#최신-기술을-반영한-커리큘럼" class="headerlink" title="최신 기술을 반영한 커리큘럼"></a>최신 기술을 반영한 커리큘럼</h3><p>첫째로 Angular와 같은 최신 프레임워크를 배우는 커리큘럼이었다는 것입니다. JavaScript를 가르치면서 프론트엔드 개발자를 양성한다는 학원은 많았습니다. 특히 국비지원 학원의 경우 수강생에게 용돈과 같은 성격의 돈을 주면서 심지어 무료로 가르친다고 하니 좋은 기회라고 생각이 들었습니다. 그러나 거의 대부분의 국비지원 학원은 프론트엔드의 최신 경향을 가르치기 보다는 jQuery와 같은 라이브러리를 가르치는 경우가 많았습니다. jQuery는 훌륭한 라이브러리지만, 오래되었고 컴포넌트 분리와 같은 최신의 프론트엔드 기술의 경향성과는 거리가 있는 기술입니다. 또한 과거 스타트업 인턴 면접에서 ‘요새는 jQuery 잘 안쓰는거 아시죠?’라는 말을 들은 적이 있어서 더욱 선택하기가 꺼려졌습니다. 다행히 패스트캠퍼스 프론트엔드 스쿨의 커리큘럼에는 현재 프론트엔드의 3대장 중 하나인 Angular를 가르친다고 되어 있었습니다. 이것은 기수마다 다르며 6기인 저는 Angular를 배웠고 7기의 경우 React, 4기의 경우 Vue.js를 배웠습니다. React와 Vue.js는 Angular와 함께 가장 인기있는 최신의 프론트엔드 프레임워크(혹은 라이브러리)라고 불립니다. 패스트캠퍼스가 최신의 기술을 다루고 도입하려는 학원이라는 점이 제게는 선택의 요인이 되었습니다.</p><h3 id="믿음직한-강사진"><a href="#믿음직한-강사진" class="headerlink" title="믿음직한 강사진"></a>믿음직한 강사진</h3><p>둘째로는 강사진이 믿음직했다는 점입니다. HTML과 CSS를 가르쳐주셨던 김데레사님의 경우 웹표준 핵심가이드북2 HTML5+CSS3의 저자입니다. 이 책은 프로그래밍을 공부하는 지인이 소개해 주어 평소 관심을 두었던 책이었기 때문에, 마치 저자의 직강을 들을 수 있다는 기대감을 주었습니다. 또한 프로그래밍 교육 책을 낼만큼 강의력과 실력이 증명되었다는 것을 기대할 수 있었습니다.<br><img src="/img/htmlcss.jpg" alt="ex_screenshot"><br><a href="http://webcafe2010.com/rwd/index.html" target="_blank" rel="noopener">웹표준 핵심가이드북2 HTML5+CSS3</a></p><p>JavaScript와 Angular를 가르쳐주신 웅모님의 경우 사실 데레사님만큼 사전에 잘 알지는 못했습니다. 그러나 poiemaweb이라는 프로그래밍 교육 사이트를 운영 중이셨고, 해당 사이트의 꼼꼼한 설명과 풍부한 예제는 웅모님의 강의에 대한 신뢰감을 심어주었습니다. 이후에 서술하겠지만 결국 웅모님은 현재 제 프로그래밍에 대한 생각에 가장 큰 영향을 주신 분이 되었습니다.</p><h3 id="지인의-추천과-비교적-공개된-하이어링-리포트"><a href="#지인의-추천과-비교적-공개된-하이어링-리포트" class="headerlink" title="지인의 추천과 비교적 공개된 하이어링 리포트"></a>지인의 추천과 비교적 공개된 하이어링 리포트</h3><p>셋째로는 지인의 추천이 있었고 채용 리포트가 공개되어 있었다는 점입니다. 스마트스터디에서 마케팅 직무로 일하고 있는 지인이 패스트캠퍼스의 디지털 마케팅 스쿨 출신이었습니다. 그 지인으로부터 패스트캠퍼스의 정보와 웹 프로그래밍 스쿨에 대한 정보, 학원 전반에 대한 추천을 들을 수 있었습니다. 그는 구직활동에 도움을 받았고 또 이를 바탕으로 실제 취업에 이르렀으니, 저 또한 이러한 기대감이 들었습니다. 또한 패스트캠퍼스 공식 홈페이지에 공개되어 있는 채용 리포트의 내용은 또한 제가 큰 기대감과 신뢰감을 주었습니다. 대개의 학원들이나 기관들이 자신들의 과정을 수료한 학생들의 취업률이나 정보를 비교적 덜 알리기 때문입니다. 그런 면에서 패스트캠퍼스는 신뢰도가 높았습니다.<br><a href="http://school.fastcampus.co.kr/dev_fds/#idx-7" target="_blank" rel="noopener">패스트캠퍼스 스쿨 하이어링 리포트</a></p><h3 id="사전과제의-난이도"><a href="#사전과제의-난이도" class="headerlink" title="사전과제의 난이도"></a>사전과제의 난이도</h3><p>넷째로 사전과제의 난이도에 신뢰감을 얻었습니다. 패스트캠퍼스의 경우 스쿨 등록 이전 사전과제가 주어지는데, 생각보다 난이도가 있는 과제였습니다. 다른 학원은 아예 사전과제가 없거나 있더라도 프로그램을 몇 개 까는게 전부였는데, 패스트캠퍼스는 달랐습니다. 난이도 있는 과제를 통해 본 스쿨의 커리큘럼이 단순하지 않고 배울 점이 있을 것이라는 기대감을 주었습니다.</p><h2 id="패스트캠퍼스-이외의-학원-기관들"><a href="#패스트캠퍼스-이외의-학원-기관들" class="headerlink" title="패스트캠퍼스 이외의 학원, 기관들"></a>패스트캠퍼스 이외의 학원, 기관들</h2><p>사실 패스트캠퍼스 뿐만 아니라 여러 국비지원 학원과 부트캠프를 돌아다니며 상담을 받곤 했습니다. 구체적인 이름을 언급하기는 좀 그래서 간략하게 선택하지 않은 이유를 적겠습니다. 위에서 언급했자시피 국비지원은 프론트엔드 개발자를 양성한다고 하지만 사실상 웹 퍼블리셔(HTML/CSS)과정과 간단한 자바스크립트와 라이브러리(jQuery)를 가르치는 정도였고, 거기에 Java의 spring을 가르침으로서 ‘풀스택 개발자’ 양성과 다름없다고 홍보를 했습니다. 풀스택 개발자가 3~6개월만에 양성된다는 것도 믿음이 가지 않았고 Java를 공부하고 싶은 마음도 없었습니다.</p><p>어떤 부트캠프는 JavaScript를 아예 가르치지 않거나(최근 JS를 가르치는 교육과정을 편성했다고 합니다.) 아니면 교육이 대부분 영어로 진행되는 단점을 갖고 있었습니다. 영어로 진행되는 수업의 경우 프로그래밍을 배우는게 아니라 영어를 배우러 가는 듯한 피로감을 느낄 것 같았습니다. 또 핑계를 찾기도 쉬울 것 같았습니다. 프로그래밍을 공부하지 않고 ‘영어’ 때문이라고 변명하고 싶지 않았습니다.</p><p>아니면 아예 인지도가 너무 떨어지거나 수료생들의 채용정보나 연봉정보가 공개되지 않은 것이 많았습니다. 이러한 이유들로 다른 학원과 기관들을 선택지에서 하나씩 제할 수 있었습니다.</p><h2 id="패스트캠퍼스-후기"><a href="#패스트캠퍼스-후기" class="headerlink" title="패스트캠퍼스 후기"></a>패스트캠퍼스 후기</h2><p>그렇다면 제가 처음에 기대했던 많은 내용을 패스트캠퍼스 프론트엔드 스쿨 과정이 전부 만족시켜줬느냐고 묻는다면 좀 어려운 질문이 될 것 같습니다. 그러나 굳이 고르라고 하면 NO 입니다. 만족스러웠던 부분도 있었고, 불만족스럽거나 실망스러웠던 부분도 있었습니다.</p><h3 id="강사진은-100-만족"><a href="#강사진은-100-만족" class="headerlink" title="강사진은 100% 만족"></a>강사진은 100% 만족</h3><p>데레사님과 웅모님에게 프로그래밍을 배운 것은 정말 소중한 경험이었습니다. 데레사님을 통해서 웹표준과 접근성을 고려한 시멘틱 마크업, 반응형 웹 디자인 등을 공부할 수 있었습니다. 같이 들었던 퍼블리셔 출신 6기생들도 감탄할 만큼 뛰어난 수업이었으며, 웹 퍼블리싱 및 프론트 개발에 대한 생각을 송두리째 바꿔주셨습니다. 특히 기억에 남는 것은 시멘틱 마크업과 접근성으로 웹개발의 질을 결정하는 요소라는 것을 알게 되었습니다.</p><!-- ![ex_screenshot](/img/poiemaweb.png) --><p><a href="http://poiemaweb.com/" target="_blank" rel="noopener">Poiemaweb</a><br>또한 웅모님을 통해 JavaScript를 배운 것은 프로그래밍에 대한 제 생각을 바꿔놓았습니다. 이전까지 ‘구현하면 된 거 아냐?’라는 생각이 프로그래밍을 대하는 제 자세였습니다. 세부적인 내용은 알면 좋고 아님 말고일 뿐이지, 결국은 현업에서 중요한 건 구현하는거 아니겠냐는 마음입니다. 하지만 실제 현업에서 일어나는 일은 유지보수가 많으며, 실제 구현하는 것조차도 이론적 지식이 없다면 효과적이고 퍼포먼스적으로 뛰어난 어플리케이션을 만들 수 없다는 것을 알게 되었습니다. 컴퓨터 메모리에 변수가 어떻게 저장되는지라든지 TypeScript에 let과 const가 왜 들어갔고 그 차이는 뭔지 등의 이론적 내용은 실제 현업에서 중요하게 생각하고 있는 것임을 알 수 있었습니다.</p><p>이외에도 기완 조교님과 특강 강사분들은 필요한 순간 적재적소에서 가려운 부위를 긁어주는 효자손과 같았습니다.</p><h3 id="전반적인-스쿨-운영과-설계의-미숙-시설이-아쉬워"><a href="#전반적인-스쿨-운영과-설계의-미숙-시설이-아쉬워" class="headerlink" title="전반적인 스쿨 운영과 설계의 미숙, 시설이 아쉬워"></a>전반적인 스쿨 운영과 설계의 미숙, 시설이 아쉬워</h3><ul><li>강사진은 믿음직했지만 스쿨 과정의 운영과정이나 프로젝트 팀 배정 절차 등은 다소 아쉬운 점이 있었습니다. 우선 스쿨 매니저님이 바빴습니다. 매니저님이 프론트엔드 6기만을 맡는게 아니라 여러 스쿨 기수를 맡고 있었기 때문에 온전히 저희에게 시간과 관심을 쏟을 수 없었습니다. 또한 업무가 많아 스쿨 기수들을 꼼꼼히 챙기기 어려웠던 것 같습니다. 강사님과 소통이 잘 되지 않아 커리큘럼 일정이 꼬이거나 수강생들과의 소통이 잘 이루어지지 못할 때가 있었고, 운영팀에서 준비한 여러 프로그램(페어프로그래밍, 애자인 방법론, 프로젝트 팀 배정 등)이 다소 프로페셔널하지 못한 느낌을 줄 때가 있었습니다. 마치 아마추어들이 한다는 느낌이 있었고 이것은 프로젝트 팀을 배정할 때 특히 두드러졌습니다. </li><li>각각의 건물들이 너무 떨어져서 자습이나 스터디를 위해 추운 겨울 밖으러 걸어나가야 할 때도 있었습니다. 그리고 편의시설이 거의 없다는 것이 많이 아쉬웠습니다.</li></ul><h2 id="총평"><a href="#총평" class="headerlink" title="총평"></a>총평</h2><p><img src="/img/3.jpg" alt="ex_screenshot"><br>패스트캠퍼스를 통해 바뀐 내 맥북(?)</p><p>비전공자로서 전문 개발자로서의 커리어를 시작하고 싶으신 분들에게 패스트캠퍼스는 나쁘지 않은 대안이라고 생각합니다. 많은 교육기관이 존재하지만 각각의 장단점이 있기 마련입니다. 패스트캠퍼스는 비교적 장점이 많고 단점이 적은 곳이라고 생각합니다. 그리고 무엇보다 강사진이 어느 교육기관에 꿀리지 않는 수준이라고 생각합니다. 스쿨과 기수마다 다르지만, 주변에서 시설이나 운영에 대해 불만족하는 분들은 있어도 강사진의 실력이나 강의력에 불만족하는 분은 보지 못했습니다.</p><p>한 가지 깨닫게 된 것은 개발자의 길은 끝이 없다는 것입니다. 패스트캠퍼스에 처음 들어오면서 기대했던 것은 ‘정답’이었습니다. 여기서 4개월 공부하여 전문 개발자가 되고 취업을 하는 것. 이것이 목표였습니다. 하지만 프로그래밍은 배우면 배울수록 알아야 하는 것이 많고 가야할 길이 구만리라는 것입니다. 돌이켜보면 4개월만에 개발자가 뚝딱 되어있는 것은 어불성설이라고 생각합니다. 혹시라도 4개월만에 2, 3년 경력에 준하는 개발자가 되길 바라는 분은 패스트캠퍼스에 실망하실 수도 있을 것 같습니다. 하지만 패스트캠퍼스는 제게 무엇을 모르고 무엇을 해야하는지를 명확히 보여준 곳이었습니다. 개발자에게 가장 필요한 명확한 자기 인식. 패스트캠퍼스는 이것을 가능하게 했습니다. 지난 4개월 간의 패스트캠퍼스에서의 공부는 전혀 후회없는 선택이었습니다. </p><p><img src="/img/1.jpg" alt="ex_screenshot"><br>긴 글 읽어주셔서 감사합니다. 누군가에겐 도움이 되었으면 좋겠네요.<br>이상 girin-dev였습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;패스트캠퍼스-프론트엔드-스쿨-6기-솔직-후기&quot;&gt;&lt;a href=&quot;#패스트캠퍼스-프론트엔드-스쿨-6기-솔직-후기&quot; class=&quot;headerlink&quot; title=&quot;패스트캠퍼스 프론트엔드 스쿨 6기 솔직 후기&quot;&gt;&lt;/a&gt;패스트캠퍼스 프론트엔드 스
      
    
    </summary>
    
      <category term="ETC" scheme="http://girin-dev.github.io/categories/ETC/"/>
    
    
      <category term="Self_Review" scheme="http://girin-dev.github.io/tags/Self-Review/"/>
    
  </entry>
  
  <entry>
    <title>진유림님 특강</title>
    <link href="http://girin-dev.github.io/2017/11/27/SL-git(Jay-jin)/"/>
    <id>http://girin-dev.github.io/2017/11/27/SL-git(Jay-jin)/</id>
    <published>2017-11-27T09:14:14.000Z</published>
    <updated>2019-01-03T03:31:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="진유림님-특강"><a href="#진유림님-특강" class="headerlink" title="진유림님 특강"></a>진유림님 특강</h1><h2 id="발표-중-나온-사이트"><a href="#발표-중-나온-사이트" class="headerlink" title="발표 중 나온 사이트"></a>발표 중 나온 사이트</h2><ul><li><a href="https://milooy.wordpress.com/" target="_blank" rel="noopener">Jay jin’s blog</a></li><li><a href="https://github.com/yeun/open-color" target="_blank" rel="noopener">open-color</a></li><li><a href="https://yop.cool/" target="_blank" rel="noopener">yop</a></li><li>slider에 공유한 발표자료들</li><li><a href="https://www.slideshare.net/jayjin0427/ss-61315271" target="_blank" rel="noopener">신입 개발자 생활백서</a></li><li><a href="https://github.com/e-/Hangul.js/" target="_blank" rel="noopener">Hangul.js</a></li><li><a href="https://firebase.google.com/" target="_blank" rel="noopener">firebase</a> vue와 친함.</li><li><a href="https://tutorial.djangogirls.org/ko/" target="_blank" rel="noopener">Django Girls</a></li></ul><h2 id="나는-왜-개발자가-되려고-하는가"><a href="#나는-왜-개발자가-되려고-하는가" class="headerlink" title="나는 왜 개발자가 되려고 하는가?"></a>나는 왜 개발자가 되려고 하는가?</h2><ul><li>높은 가지의 열매와 낮은 가지의 열매<ul><li>낮은 열매란?</li></ul></li><li>한 우물만 파야하는거 아니야?<ul><li>뭔가 손에 잡히지 않을 때 다른 분야에 대해 공부를 해도 심적으로 위안이 되더라</li><li>헤맸던 것도 나무를 오르는 과정이라고 생각하니까 마음이 편해요~</li></ul></li></ul><h2 id="낮은-열매-따먹기"><a href="#낮은-열매-따먹기" class="headerlink" title="낮은 열매 따먹기"></a>낮은 열매 따먹기</h2><ul><li>예쁜거 만들기<ul><li>자바와 자료구조보다 프론트엔드(HTML, CSS, JS)가 더 재미있더라</li><li>파이썬 &amp; 장고 꿀잼~!</li><li>해커톤 다수 참여</li></ul></li><li>9XD<ul><li>온오프라인 커뮤니티 활동</li></ul></li><li>일일커밋<ul><li>코딩하는 습관</li><li>어뷰징 금지</li><li>Codewars.com 타인의 코드를 보는 습관(일일코딩)</li><li>오픈소스 활동</li></ul></li><li>작은 발표<ul><li>20명 앞에서 10분 발표를 한 것을 시작으로 다양한 발표 활동과 슬라이드 공유</li></ul></li></ul><h2 id="면접과-Github"><a href="#면접과-Github" class="headerlink" title="면접과 Github"></a>면접과 Github</h2><ul><li>보는 것들<ul><li>코딩스타일, 탭과 스페이스 혼용여부</li><li>오픈소스 기여도</li><li>어떤 저장소에 Star를 찍고 Fork를 했는지</li></ul></li><li>단점<ul><li>저장소에 DB 아이디와 암호를 올리는 경우(env파일을 이용하는 방법 등으로 해결해야 함)</li><li>이메일을 네이버 쓰는 경우.</li><li>깃헙 주소를 내지 않아도 어떻게든 찾아내서 보더라</li></ul></li></ul><h2 id="github-패스트포워드가-아닌-상황에서-머지하는-법"><a href="#github-패스트포워드가-아닌-상황에서-머지하는-법" class="headerlink" title="github 패스트포워드가 아닌 상황에서 머지하는 법"></a>github 패스트포워드가 아닌 상황에서 머지하는 법</h2><ul><li>선머지 후풀리퀘<ul><li>???</li></ul></li><li>Rebase(히스토리 조작)<ul><li>force push?</li></ul></li></ul><h2 id="번외-팜므어-번역기"><a href="#번외-팜므어-번역기" class="headerlink" title="번외: 팜므어 번역기"></a>번외: 팜므어 번역기</h2><ul><li><h2 id="느낀-점"><a href="#느낀-점" class="headerlink" title="느낀 점"></a>느낀 점</h2></li><li>github의 pull request도 현업에서는 굉장히 자세하고 구체적으로 쓰는구나.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;진유림님-특강&quot;&gt;&lt;a href=&quot;#진유림님-특강&quot; class=&quot;headerlink&quot; title=&quot;진유림님 특강&quot;&gt;&lt;/a&gt;진유림님 특강&lt;/h1&gt;&lt;h2 id=&quot;발표-중-나온-사이트&quot;&gt;&lt;a href=&quot;#발표-중-나온-사이트&quot; class=&quot;he
      
    
    </summary>
    
      <category term="ETC" scheme="http://girin-dev.github.io/categories/ETC/"/>
    
    
  </entry>
  
</feed>
